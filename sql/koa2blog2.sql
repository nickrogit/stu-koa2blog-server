# ************************************************************
# Sequel Pro SQL dump
# Version 4541
#
# http://www.sequelpro.com/
# https://github.com/sequelpro/sequelpro
#
# Host: (MySQL 5.6.33)
# Database: koa2blog
# Generation Time: 2018-05-16 12:45:53 +0000
# ************************************************************


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


# Dump of table articles
# ------------------------------------------------------------

DROP TABLE IF EXISTS `articles`;

CREATE TABLE `articles` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `postId` int(11) DEFAULT NULL,
  `date` bigint(100) DEFAULT NULL,
  `tags` varchar(500) DEFAULT NULL,
  `title` varchar(100) DEFAULT NULL,
  `desc` varchar(1000) DEFAULT NULL,
  `detail` varchar(20000) DEFAULT NULL,
  `readNum` int(11) DEFAULT NULL,
  `wordCount` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `test` (`postId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='CREATE TABLE `tags` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;';

LOCK TABLES `articles` WRITE;
/*!40000 ALTER TABLE `articles` DISABLE KEYS */;

INSERT INTO `articles` (`id`, `postId`, `date`, `tags`, `title`, `desc`, `detail`, `readNum`, `wordCount`)
VALUES
	(1,1,1494806400000,'nodejs','npm install -g express后命令行无法使用express','解决<code>npm install -g express</code>后命令行无法使用<code>express</code>','<p>express已经把命令行工具单独分离出来了，需要单独安装</p>\n<p>1、安装express及相关组件-----cmd下运行：npm install express -gd</p>\n<p>2、安装the executable----------cmd下运行：<br>express3:<br>    npm install -g express-generator@3<br>express4:<br>    npm install -g express-generator即可</p>\n<p>3、express [ 创建express项目的名称 ] 就能创建express项目了。</p>',40,10000),
	(2,2,1496275200000,'vue,vuex','使用Vuex ','本文主要记录<code>vuex</code>的基本使用','<h1 id=\"-\">使用vuex</h1>\n<p><strong>安装：</strong><br><code>npm install --save vuex</code></p>\n<p><strong>引入：</strong></p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> Vuex <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vuex\'</span>\nVue.use(Vuex)\n</code></pre>\n<h2 id=\"state\">State</h2>\n<p><strong>存储状态数据</strong></p>\n<p>在根实例中注册 store 选项，就能通过this.$store.state获取数据</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">new</span> <span class=\"hljs-tag\">Vue</span>(<span class=\"hljs-rules\">{\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">el</span>:<span class=\"hljs-value\"> <span class=\"hljs-string\">\'#app\'</span>,\n  store,// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  render: h =&gt; <span class=\"hljs-function\">h(App)</span>\n</span></span></span>})\n\n</code></pre>\n<p>mapState辅助函数，将state映射到计算属性中去</p>\n<p>//我是组件</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">import</span> {mapState} from <span class=\"hljs-string\">\'vuex\'</span>\n<span class=\"hljs-reserved\">export</span> <span class=\"hljs-reserved\">default</span> {\n  <span class=\"hljs-attribute\">computed</span>: mapState({\n    <span class=\"hljs-attribute\">count</span>: state<span class=\"hljs-function\"> =&gt;</span> state.count\n  })\n}\n</code></pre>\n<h2 id=\"mutations\">Mutations</h2>\n<p><strong>改变State中的状态，相当于注册一个事件，每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。<br>必须为同步函数。</strong></p>\n<pre><code class=\"lang-js\">mutations: {\n    mutationName(<span class=\"hljs-keyword\">state</span>) {\n      <span class=\"hljs-regexp\">//</span> 在此改变<span class=\"hljs-keyword\">state</span>中的数据\n    }\n  }\n</code></pre>\n<p>当触发一个mutationName时，需要调用此函数：<br><code>store.commit(mutationName)</code></p>\n<p>提交载荷（Payload）<br>你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：</p>\n<pre><code class=\"lang-js\">mutations: {\n  increment (<span class=\"hljs-keyword\">state</span>, n) {\n    <span class=\"hljs-keyword\">state</span>.count += n\n  }\n}\nstore.commit(<span class=\"hljs-string\">\'increment\'</span>, <span class=\"hljs-number\">10</span>)\n</code></pre>\n<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>\n<pre><code class=\"lang-js\">mutations: {\n  increment (<span class=\"hljs-keyword\">state</span>, payload) {\n    <span class=\"hljs-keyword\">state</span>.count += payload.amount\n  }\n}\nstore.commit(<span class=\"hljs-string\">\'increment\'</span>, {\n  amount: <span class=\"hljs-number\">10</span>\n})\n\n</code></pre>\n<p><strong>在组件中使用this.$store.commit(&#39;mutationName&#39;)触发：</strong></p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">methods</span>: <span class=\"hljs-cell\">{\n    handleClick() {\n      this.$store.commit(<span class=\"hljs-string\">\'mutationName\'</span>)\n    }</span>\n  }\n</code></pre>\n<p><strong>或者使用辅助函数mapMutations直接将触发函数映射到methods上，</strong></p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">methods</span>: mapMutations(<span class=\"hljs-matrix\">[\n    <span class=\"hljs-string\">\'mutationName\'</span>\n  ]</span>)\n\n</code></pre>\n<h2 id=\"actions\">Actions</h2>\n<p>也可以用于改变状态。<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。</p>\n<pre><code class=\"lang-js\">actions: <span class=\"hljs-cell\">{\n  actionName({ commit }</span>) <span class=\"hljs-cell\">{\n    //dosomething\n    commit(<span class=\"hljs-string\">\'mutationName\'</span>)\n  }</span>\n}\n</code></pre>\n<p>Action 通过 <strong>store.dispatch</strong> 方法触发：</p>\n<p><code>store.dispatch(&#39;increment&#39;)</code></p>\n<h2 id=\"getters\">Getters</h2>\n<p>有些状态需要做二次处理，就可以使用getters。通过this.$store.getters.valueName对派生出来的状态进行访问。或者直接使用辅助函数mapGetters将其映射到本地计算属性中去。</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> getters = {\n  strLength: state =&gt; state.aString.<span class=\"hljs-built_in\">length</span>\n}\n</code></pre>\n<p>//上面的代码根据aString状态派生出了一个strLength状态</p>\n<p>在组件中使用</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> {mapGetters} from <span class=\"hljs-string\">\'vuex\'</span>\n\n<span class=\"hljs-comment\">//我是一个组件</span>\nexport <span class=\"hljs-keyword\">default</span> {\n  computed: mapGetters([\n    <span class=\"hljs-string\">\'strLength\'</span>\n  ])\n}\n</code></pre>\n<p><a href=\"https://vuex.vuejs.org/zh-cn/actions.html\">https://vuex.vuejs.org/zh-cn/actions.html</a><br><a href=\"http://blog.csdn.net/sinat_17775997/article/details/54943797\">http://blog.csdn.net/sinat_17775997/article/details/54943797</a><br><a href=\"http://blog.csdn.net/github_26672553/article/details/53176778\">http://blog.csdn.net/github_26672553/article/details/53176778</a></p>',20,20),
	(3,3,1496620800000,'javascript','深拷贝与浅拷贝','本文主要介绍深拷贝与浅拷贝的区别以及实现方法。','<h1 id=\"-\">深拷贝和浅拷贝</h1>\n<h2 id=\"js-\">js浅拷贝</h2>\n<p>浅拷贝就是简单的赋值，因为对象和数组在赋值时都是引用传递，所以只是传递 一个指针，改变值的时候会改变初始对象的值。</p>\n<h2 id=\"js-\">js深拷贝</h2>\n<p>若需改变值时不影响初始对象的值，则需要用到深拷贝。</p>\n<blockquote>\n<p>方法一：slice,原理：slice返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr1 = deepArr.slice(<span class=\"hljs-number\">0</span>);\ndeepArr1[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr + <span class=\"hljs-string\">\" \"</span> + deepArr1);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n<blockquote>\n<p>方法二：concat，原理：concat返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr3 = deepArr2.concat();\ndeepArr3[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr2 + <span class=\"hljs-string\">\" \"</span> + deepArr3);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n<h2 id=\"js-\">js浅拷贝</h2>\n<p>浅拷贝就是简单的赋值，因为对象和数组在赋值时都是引用传递，所以只是传递 一个指针，改变值的时候会改变初始对象的值。</p>\n<h2 id=\"js-\">js深拷贝</h2>\n<p>若需改变值时不影响初始对象的值，则需要用到深拷贝。</p>\n<blockquote>\n<p>方法一：slice,原理：slice返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr1 = deepArr.slice(<span class=\"hljs-number\">0</span>);\ndeepArr1[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr + <span class=\"hljs-string\">\" \"</span> + deepArr1);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n<blockquote>\n<p>方法二：concat，原理：concat返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr3 = deepArr2.concat();\ndeepArr3[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr2 + <span class=\"hljs-string\">\" \"</span> + deepArr3);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n<h2 id=\"js-\">js浅拷贝</h2>\n<p>浅拷贝就是简单的赋值，因为对象和数组在赋值时都是引用传递，所以只是传递 一个指针，改变值的时候会改变初始对象的值。</p>\n<h2 id=\"js-\">js深拷贝</h2>\n<p>若需改变值时不影响初始对象的值，则需要用到深拷贝。</p>\n<blockquote>\n<p>方法一：slice,原理：slice返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr1 = deepArr.slice(<span class=\"hljs-number\">0</span>);\ndeepArr1[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr + <span class=\"hljs-string\">\" \"</span> + deepArr1);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n<blockquote>\n<p>方法二：concat，原理：concat返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr3 = deepArr2.concat();\ndeepArr3[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr2 + <span class=\"hljs-string\">\" \"</span> + deepArr3);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n<h2 id=\"js-\">js浅拷贝</h2>\n<p>浅拷贝就是简单的赋值，因为对象和数组在赋值时都是引用传递，所以只是传递 一个指针，改变值的时候会改变初始对象的值。</p>\n<h2 id=\"js-\">js深拷贝</h2>\n<p>若需改变值时不影响初始对象的值，则需要用到深拷贝。</p>\n<blockquote>\n<p>方法一：slice,原理：slice返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr1 = deepArr.slice(<span class=\"hljs-number\">0</span>);\ndeepArr1[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr + <span class=\"hljs-string\">\" \"</span> + deepArr1);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n<blockquote>\n<p>方法二：concat，原理：concat返回一个新数组</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> deepArr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> deepArr3 = deepArr2.concat();\ndeepArr3[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\'test\'</span>;\nconsole.<span class=\"hljs-keyword\">log</span>(<span class=\"hljs-string\">\'deep copy: \'</span> + deepArr2 + <span class=\"hljs-string\">\" \"</span> + deepArr3);   <span class=\"hljs-comment\">//deep copy: 1,2,3 1,test,3</span>\n</code></pre>\n',10,12345),
	(4,4,1496707200000,'vue','vue自定义指令','本文主要介绍vue自定义指令的语法','<h1 id=\"-\"><strong>自定义指令语法</strong></h1>\n<h2 id=\"-update-\">//直接绑定函数，作用等同于update,不做准备工作和扫尾工作</h2>\n<p>Vue.directive(id, function(){<br>  // 这个函数会被作为 update() 函数使用<br>});</p>\n<h2 id=\"-\">钩子函数</h2>\n<ol>\n<li>bind: 仅调用一次，当指令第一次绑定元素的时候。<br>2.update: 第一次是紧跟在 bind 之后调用，获得的参数是绑定的初始值；以后每当绑定的值发生变化就会被调用，获得新值与旧值两个参数。<br>3.unbind：仅调用一次，当指令解绑元素的时候。<br>例子：<br>Vue.directive(&#39;my-directive&#39;, {<br>bind: function () {<br> // 做绑定的准备工作<br> // 比如添加事件监听器，或是其他只需要执行一次的复杂操作<br>},<br>update: function (newValue, oldValue) {<br> // 根据获得的新值执行对应的更新<br> // 对于初始值也会被调用一次<br>},<br>unbind: function () {<br> // 做清理工作<br> // 比如移除在 bind() 中添加的事件监听器<br>}<br>})</li>\n</ol>\n<h2 id=\"-\">指令对象上暴露了一些有用的公开属性</h2>\n<p>el: 指令绑定的元素<br>vm: 拥有该指令的上下文 ViewModel<br>expression: 指令的表达式，不包括参数和过滤器<br>arg: 指令的参数<br>raw: 未被解析的原始表达式<br>name: 不带前缀的指令名<br><strong>这些属性是只读的，不要修改它们。你也可以给指令对象附加自定义的属性，但是注意不要覆盖已有的内部属性</strong><br>例子：</p>\n<div id=\"demo\" v-demo-directive=\"LightSlateGray : msg\"></div>\n\n\n\n<pre><code>Vue.directive(<span class=\"hljs-string\">\'demoDirective\'</span>, {\n        bind: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n            <span class=\"hljs-keyword\">this</span>.el.style.color = <span class=\"hljs-string\">\'#fff\'</span>\n            <span class=\"hljs-keyword\">this</span>.el.style.backgroundColor = <span class=\"hljs-keyword\">this</span>.arg\n        },\n        update: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(value)</span> {</span>\n            <span class=\"hljs-keyword\">this</span>.el.innerHTML =\n                    <span class=\"hljs-string\">\'name - \'</span>       + <span class=\"hljs-keyword\">this</span>.name + <span class=\"hljs-string\">\'&lt;br&gt;\'</span> +\n                    <span class=\"hljs-string\">\'raw - \'</span>        + <span class=\"hljs-keyword\">this</span>.raw + <span class=\"hljs-string\">\'&lt;br&gt;\'</span> +\n                    <span class=\"hljs-string\">\'expression - \'</span> + <span class=\"hljs-keyword\">this</span>.expression + <span class=\"hljs-string\">\'&lt;br&gt;\'</span> +\n                    <span class=\"hljs-string\">\'argument - \'</span>   + <span class=\"hljs-keyword\">this</span>.arg + <span class=\"hljs-string\">\'&lt;br&gt;\'</span> +\n                    <span class=\"hljs-string\">\'value - \'</span>      + value\n        }\n    });\n    <span class=\"hljs-keyword\">var</span> demo = <span class=\"hljs-keyword\">new</span> Vue({\n        el: <span class=\"hljs-string\">\'#demo\'</span>,\n        data: {\n            msg: <span class=\"hljs-string\">\'hello!\'</span>\n        }\n    })\n</code></pre><p><a href=\"http://www.open-open.com/lib/view/open1452421025839.html\">http://www.open-open.com/lib/view/open1452421025839.html</a><br><a href=\"http://blog.csdn.net/zuoziji416/article/details/53514412\">http://blog.csdn.net/zuoziji416/article/details/53514412</a><br><a href=\"https://wenku.baidu.com/view/b9c246becd22bcd126fff705cc17552707225e08.html\">https://wenku.baidu.com/view/b9c246becd22bcd126fff705cc17552707225e08.html</a></p>\n',10,10),
	(5,5,1496793600000,'css','css3选择器','本文主要记录下css3新增的选择器','<h1 id=\"css3-\">CSS3结构选择器</h1>\n<h2 id=\"e-nth-child-n-\">E:nth-child(n)</h2>\n<p>选择所有在其父元素中第n个位置的匹配E的子元素。<br>注意，参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）<br>参数的索引从 1 开始。<br>tr:nth-child(3)匹配所有表格中第3排的tr；<br>tr:nth-child(2n+1)匹配所有表格的奇数行；<br>tr:nth-child(2n)匹配所有表格的偶数行；<br>tr:nth-child(odd)匹配所有表格的奇数行；<br>tr:nth-child(even)匹配所有表格的偶数行；</p>\n<blockquote>\n<pre><code><span class=\"hljs-tag\">table</span> <span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">table-layout</span>:<span class=\"hljs-value\"> fixed</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">border-collapse</span>:<span class=\"hljs-value\"> collapse</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">empty-cells</span>:<span class=\"hljs-value\"> show</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n\n<span class=\"hljs-tag\">tr</span><span class=\"hljs-pseudo\">:nth-child(even)</span> <span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> <span class=\"hljs-hexcolor\">#f5f5f5</span></span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre></blockquote>\n<h2 id=\"e-nth-last-child-n-\">E:nth-last-child(n)</h2>\n<p>选择所有在其父元素中倒数第n个位置的匹配E的子元素</p>\n<h2 id=\"e-nth-of-type-n-\">E:nth-of-type(n)</h2>\n<p>选择父元素中第n个位置，且匹配E的子元素。<br>注意，所有匹配E的子元素被分离出来单独排序。非E的子元素不参与排序。参数n可以是数字，关键字、公式。<br>例：p:nth-of-type(1)</p>\n<h2 id=\"e-nth-last-of-type-n-\">E:nth-last-of-type(n)</h2>\n<p>选择父元素中倒数第n个位置，且匹配E的子元素。</p>\n<h2 id=\"e-last-child\">E:last-child</h2>\n<p>选择位于其父元素中最后一个位置，且匹配E的子元素。</p>\n<h2 id=\"e-only-child\">E:only-child</h2>\n<p> 选择其父元素只包含一个子元素，且该子元素匹配E。</p>\n<h2 id=\"e-first-of-type\">E:first-of-type</h2>\n<p>   选择位于其父元素中且匹配E的第一个同类型的子元素。该选择器的功能类似于 E:nth-of-type(1)</p>\n<h2 id=\"e-last-of-type\">E:last-of-type</h2>\n<p>   选择位于其父元素中且匹配E的最后第一个同类型的子元素。该选择器的功能类似于 E:nth-last-of-type(1)</p>\n<h2 id=\"e-only-of-type\">E:only-of-type</h2>\n<p>选择其父元素只包含一个同类型的子元素，且该子元素匹配E。</p>\n<h2 id=\"e-not-s-\">E:not(s)</h2>\n<p> 否定伪类选择器类型。<br>选择匹配E的所有元素，且过滤掉匹配s选择符的任意元素。<br>s是一个简单结构的选择器，不能使用符合选择器，</p>\n',20,10),
	(6,6,1496880000000,'css','居中一个div','本文介绍了使一个div居中的几种方法','<h1 id=\"-\">居中一个div</h1>\n<h2 id=\"-\">已知宽度水平居中</h2>\n<pre><code class=\"lang-css\"><span class=\"hljs-tag\">div</span><span class=\"hljs-rules\">{\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"><span class=\"hljs-number\">200</span>px</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-value\"><span class=\"hljs-number\">0</span> auto</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<h2 id=\"-\">水平垂直居中-已知宽高</h2>\n<pre><code class=\"lang-css\"><span class=\"hljs-tag\">div</span> <span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> absolute</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">300</span>px</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">300</span>px</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-value\"> auto</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">bottom</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">right</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> pink</span></span>;    <span class=\"hljs-comment\">/* 方便看效果 */</span>\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<h2 id=\"-\">水平垂直居中 - 已知宽高</h2>\n<pre><code class=\"lang-css\"><span class=\"hljs-tag\">div</span> <span class=\"hljs-rules\">{\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> absolute</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"><span class=\"hljs-number\">500</span>px</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"><span class=\"hljs-number\">300</span>px</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">50</span>%</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">50</span>%</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-value\"> -<span class=\"hljs-number\">150</span>px <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> -<span class=\"hljs-number\">250</span>px</span></span>;         <span class=\"hljs-comment\">/* 外边距为自身宽高的一半 */</span>\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> pink</span></span>;         <span class=\"hljs-comment\">/* 方便看效果 */</span>\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<h2 id=\"-\">水平垂直居中-宽高不确定</h2>\n<pre><code class=\"lang-css\"><span class=\"hljs-tag\">div</span> <span class=\"hljs-rules\">{\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> absolute</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"><span class=\"hljs-number\">500</span>px</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"><span class=\"hljs-number\">300</span>px</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">50</span>%</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">50</span>%</span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-value\"> <span class=\"hljs-function\">translate(-<span class=\"hljs-number\">50</span>%, -<span class=\"hljs-number\">50</span>%)</span></span></span>;\n     <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> pink</span></span>;         <span class=\"hljs-comment\">/* 方便看效果 */</span>\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<h2 id=\"-\">水平垂直居中 - 未知宽高</h2>\n<blockquote>\n<p>flex 布局 实际使用时应考虑兼容性</p>\n</blockquote>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.container</span> {\n    <span class=\"hljs-attribute\">display</span><span class=\"hljs-value\">: flex;</span>\n    <span class=\"hljs-attribute\">align-items</span><span class=\"hljs-value\">: center;</span>         <span class=\"hljs-comment\">/* 垂直居中 */</span>\n    <span class=\"hljs-attribute\">justify-content</span><span class=\"hljs-value\">: center;</span>    <span class=\"hljs-comment\">/* 水平居中 */</span>\n\n}\n<span class=\"hljs-class\">.container</span> <span class=\"hljs-tag\">div</span> { c\n    <span class=\"hljs-attribute\">width</span><span class=\"hljs-value\">: <span class=\"hljs-number\">100</span>px;</span>\n    <span class=\"hljs-attribute\">height</span><span class=\"hljs-value\">: <span class=\"hljs-number\">100</span>px;</span>\n    <span class=\"hljs-attribute\">background-color</span><span class=\"hljs-value\">: pink;</span>        <span class=\"hljs-comment\">/* 方便看效果 */</span>\n}\n</code></pre>\n',NULL,NULL),
	(7,7,1497225600000,'bug,FAQ','移动端h5页面遇到的一些问题以及解决方法','本文将会持续记录h5项目过程中遇到的一些问题以及处理方法。','<h1 id=\"-\">移动端h5页面遇到的一些问题以及解决方法</h1>\n<h3 id=\"ios-button-input-\">ios上button，input等元素连续点击，页面会上移</h3>\n<blockquote>\n<p>事件触发频率过高导致的响应速度跟不上触发频率，需要使用 <strong>函数防抖（debounce）</strong> 限制函数触发频率</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/chenyinkai/blog/issues/24\">具体使用参考这里</a></p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">const</span> <span class=\"hljs-function\"><span class=\"hljs-title\">debounce</span> = <span class=\"hljs-params\">(fn, wait = <span class=\"hljs-number\">0</span>)</span> =&gt;</span> {\n    <span class=\"hljs-reserved\">let</span> inDebounce;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-reserved\">function</span> () {\n        <span class=\"hljs-reserved\">const</span> context = <span class=\"hljs-keyword\">this</span>;\n        <span class=\"hljs-reserved\">const</span> args = arguments;\n        clearTimeout(inDebounce);\n        inDebounce = setTimeout<span class=\"hljs-function\"><span class=\"hljs-params\">(() =&gt; fn.apply(context, args), wait)</span>;\n    };\n};</span>\n</code></pre>\n<h3 id=\"-\">移动端滚动穿透</h3>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2016/12/web-mobile-scroll-prevent-window-js-css/\">解决方法见这里</a></p>\n<h3 id=\"-fixed-\">移动端出现输入框时，底部内容（fixed定位元素）会被顶到输入框上面去</h3>\n<p>解决方法：<br>1.添加事件，点击输入框时，使底部内容消失<br>2.<a href=\"http://efe.baidu.com/blog/mobile-fixed-layout/\">http://efe.baidu.com/blog/mobile-fixed-layout/</a></p>\n<h3 id=\"ios-\">ios会识别长数字为号码</h3>\n<blockquote>\n<p>增加 <code>meta</code></p>\n</blockquote>\n<p><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code></p>\n<h3 id=\"ios-\">ios设备无法自动播放音频</h3>\n<blockquote>\n<p>监听触摸事件播放</p>\n</blockquote>\n<pre><code class=\"lang-javascript\">$(<span class=\"hljs-string\">\'html\'</span>).one(<span class=\"hljs-string\">\'touchstart\'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    audio.play()\n})\n\n</code></pre>\n<h3 id=\"-ios-android-\">禁止ios和android用户选中文字</h3>\n<p><code>-webkit-user-select:none</code></p>\n<h3 id=\"ios-input-\">ios下取消input在输入的时候英文首字母的默认大写</h3>\n<p><code>&lt;input type=&quot;text&quot; autocapitalize=&quot;none&quot;&gt;</code></p>\n<h3 id=\"-ios-\">调用ios或者安卓拨号功能</h3>\n<p><code>&lt;a href=&quot;tel:10010&quot;&gt;10010&lt;/a&gt;</code></p>\n<h3 id=\"-\">上下拉动滚动条时卡顿、慢</h3>\n<blockquote>\n<p>ios设置 <code>overflow: scroll;</code> 时滚动卡顿</p>\n</blockquote>\n<pre><code class=\"lang-css\"><span class=\"hljs-tag\">body</span> <span class=\"hljs-rules\">{\n <span class=\"hljs-rule\"><span class=\"hljs-attribute\">-webkit-overflow-scrolling</span>:<span class=\"hljs-value\"> touch</span></span>;\n <span class=\"hljs-rule\"><span class=\"hljs-attribute\">overflow-scrolling</span>:<span class=\"hljs-value\"> touch</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<h3 id=\"iphone-ipad-\">iphone及ipad下输入框默认内阴影</h3>\n<pre><code class=\"lang-css\"><span class=\"hljs-tag\">Element</span><span class=\"hljs-rules\">{\n <span class=\"hljs-rule\"><span class=\"hljs-attribute\">-webkit-appearance</span>:<span class=\"hljs-value\"> none</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n',NULL,NULL),
	(8,8,1498435200000,'vue,vue-cli','vue-cli构建的项目打包后的路径问题','解决vue-cli构建的项目打包后的路径问题','<h1 id=\"-\">vue-cli打包的项目路径问题</h1>\n<h2 id=\"-\">非根目录下的配置</h2>\n<p>文章较老，见#40</p>\n<h2 id=\"-\">背景图片路径问题</h2>\n<p>在 data 中导入图片数据</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-typedef\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-container\">()</span> <span class=\"hljs-container\">{\n    <span class=\"hljs-title\">return</span>{\n        <span class=\"hljs-title\">bg</span>:<span class=\"hljs-title\">require</span>(\'./<span class=\"hljs-title\">openIndexBG2</span>.<span class=\"hljs-title\">jpg\'</span>)\n    }</span></span>\n}\n</code></pre>\n<p>然后再绑定</p>\n<pre><code class=\"lang-html\">&lt;div :style=<span class=\"hljs-string\">\"{backgroundImage: \'</span>url(<span class=\"hljs-string\">\' + bg + \'</span>)<span class=\"hljs-string\">\'}\"</span> &gt;\n</code></pre>\n<p>这样可以避免背景图片路径产生错误</p>',NULL,NULL),
	(9,9,1499990400000,'vue,vue-router','vue-router一些用法和笔记','记录vue-router使用过程中的笔记','<h1 id=\"-\">vue-router一些用法和笔记</h1>\n<h2 id=\"-\">动态路由配置方法</h2>\n<pre><code class=\"lang-js\"><span class=\"hljs-title\">export</span> <span class=\"hljs-default\"><span class=\"hljs-keyword\">default</span> new <span class=\"hljs-type\">Router</span><span class=\"hljs-container\">({\n  <span class=\"hljs-title\">routes</span>: [\n    {\n      <span class=\"hljs-title\">path</span>: \'/<span class=\"hljs-title\">router01</span>/:<span class=\"hljs-title\">name\'</span>,\n      <span class=\"hljs-title\">name</span>: \'<span class=\"hljs-type\">RainRouter01</span>\',\n      <span class=\"hljs-title\">component</span>: <span class=\"hljs-type\">RainRouter01</span>\n    }\n  ]\n})</span></span>\n</code></pre>\n<blockquote>\n<p>获取路由参数</p>\n</blockquote>\n<pre><code class=\"lang-html\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span>&gt;</span></span><span class=\"hljs-expression\">{{$<span class=\"hljs-variable\">route.params.name</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span></span>\n</code></pre>\n<h2 id=\"-\">嵌套路由</h2>\n<blockquote>\n<p>在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置，注意: 其<code>parent</code>的 <code>template</code> 必须有 <code>router-view</code> 标签</p>\n</blockquote>\n<pre><code class=\"lang-js\">children: [\n  {\n    path: <span class=\"hljs-string\">\'Child01\'</span>,\n    name: <span class=\"hljs-string\">\'Child01\'</span>,\n    component: Child01\n  },\n  {\n    path: <span class=\"hljs-string\">\'Child02\'</span>,\n    name: <span class=\"hljs-string\">\'Child02\'</span>,\n    component: Child02\n  }\n]\n</code></pre>\n<h2 id=\"-\">路由导航</h2>\n<ul>\n<li><p>声明式：<code>&lt;router-link to:&gt;&lt;/router-link&gt;</code> 通过路由标签中的 to 属性</p>\n</li>\n<li><p>编程式：</p>\n<pre><code>  <span class=\"hljs-number\">1.</span> <span class=\"hljs-string\">`router.push()`</span> <span class=\"hljs-comment\">//会产生历史记录</span>\n  <span class=\"hljs-number\">2.</span> <span class=\"hljs-string\">`router.replace()`</span> <span class=\"hljs-comment\">//无历史记录</span>\n  <span class=\"hljs-number\">3.</span> <span class=\"hljs-string\">`go()`</span>\n</code></pre></li>\n</ul>\n<h2 id=\"-\">命名路由</h2>\n<blockquote>\n<p>在路由上增加“name”属性：<br><code>&lt;router-link :to=&quot;{ name: &#39;child01&#39;, params: { name:child01}}&quot;&gt;User&lt;/router-link&gt;</code><br>或者<br><code>router.push({ name: &#39;child02&#39;, params: { name: child02 }})</code><br>方式为路由传递参数</p>\n</blockquote>\n<pre><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">router-view</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">router-view</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">router-view</span>  <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">router-view</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">router-view</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"b\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">router-view</span>&gt;</span>\n</code></pre>\n<pre><code class=\"lang-js\"><span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">path</span>:<span class=\"hljs-value\"> <span class=\"hljs-string\">\'/\'</span>,\n    components: {\n      default: Foo,\n      a: Bar,\n      b: Baz\n    </span></span></span>}\n}\n</code></pre>\n<h2 id=\"-\">重定向和别名</h2>\n<ul>\n<li>重定向 通过配置 <code>redirect</code> 实现</li>\n<li>别名 通过 <code>alias</code> 属性实现</li>\n</ul>\n<h2 id=\"-\">导航钩子</h2>\n<pre><code class=\"lang-js\">before<span class=\"hljs-variable\">RouteEnter</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">beforeRouteUpdate</span> <span class=\"hljs-params\">(<span class=\"hljs-number\">2.2</span> 新增)</span>\n<span class=\"hljs-title\">beforeRouteLeave</span></span>\n</code></pre>\n<ul>\n<li>to: Route: 即将要进入的目标 路由对象</li>\n<li>from: Route: 当前导航正要离开的路由</li>\n<li>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。<br>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。<br>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。<br>next(&#39;/&#39;) 或者 next({ path: &#39;/&#39; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</li>\n</ul>\n',NULL,NULL),
	(10,10,1500249600000,'bug,FAQ','移动端如何实现1px的细线','<h2 id=\"-\">前言</h2>\n<p>在做移动端项目的时候，我们往往需要设置1px的边框，但是 <code>border-width:1px;</code> 效果出来的边框却往往比1px要粗。本文主要介绍移动端实现1px边框的几种实现方案。</p>','<h1 id=\"-\">移动端如何实现1px的细线</h1>\n<h2 id=\"-\">前言</h2>\n<p>在做移动端项目的时候，我们往往需要设置1px的边框，但是 <code>border-width:1px;</code> 效果出来的边框却往往比1px要粗。本文主要介绍移动端实现1px边框的几种实现方案。</p>\n<h2 id=\"-\">实现方案：</h2>\n<h3 id=\"1-\">1.多背景渐变</h3>\n<blockquote>\n<p>设置1px的渐变背景，50%有颜色，50%透明。。</p>\n</blockquote>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.background-gradient-1px</span><span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background</span>:<span class=\"hljs-value\"> <span class=\"hljs-function\">-webkit-gradient(linear, left top, left bottom, <span class=\"hljs-function\">color-stop(.<span class=\"hljs-number\">5</span>, transparent)</span>, <span class=\"hljs-function\">color-stop(.<span class=\"hljs-number\">5</span>, #c8c7cc)</span>, <span class=\"hljs-function\">to(#c8c7cc)</span>)</span> left bottom repeat-x</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-size</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">100</span>% <span class=\"hljs-number\">1</span>px</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<h3 id=\"2-box-shadow-\">2.box-shadow 模拟边框</h3>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.box-shadow-1px</span> <span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">border</span>:<span class=\"hljs-value\"> none</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">box-shadow</span>:<span class=\"hljs-value\"> inset <span class=\"hljs-number\">0</span>px -<span class=\"hljs-number\">1</span>px <span class=\"hljs-number\">1</span>px -<span class=\"hljs-number\">1</span>px <span class=\"hljs-hexcolor\">#c8c7cc</span></span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<h3 id=\"3-before-after-transform\">3.使用伪类 :before, :after 与 transform</h3>\n<blockquote>\n<p>单条 <code>border</code> 样式设置</p>\n</blockquote>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.scale-1px</span><span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> relative</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">border</span>:<span class=\"hljs-value\">none</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n<span class=\"hljs-class\">.scale-1px</span><span class=\"hljs-pseudo\">:after</span><span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">content</span>:<span class=\"hljs-value\"> <span class=\"hljs-string\">\'\'</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> absolute</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">bottom</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background</span>:<span class=\"hljs-value\"> <span class=\"hljs-hexcolor\">#000</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">100</span>%</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">1</span>px</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">-webkit-transform</span>:<span class=\"hljs-value\"> <span class=\"hljs-function\">scaleY(<span class=\"hljs-number\">0.5</span>)</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-value\"> <span class=\"hljs-function\">scaleY(<span class=\"hljs-number\">0.5</span>)</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">-webkit-transform-origin</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">transform-origin</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span></span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<blockquote>\n<p>四条 <code>border</code> 样式</p>\n</blockquote>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.scale-1px</span><span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> relative</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin-bottom</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">20</span>px</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">border</span>:<span class=\"hljs-value\">none</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n<span class=\"hljs-class\">.scale-1px</span><span class=\"hljs-pseudo\">:after</span><span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">content</span>:<span class=\"hljs-value\"> <span class=\"hljs-string\">\'\'</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> absolute</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">border</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">1</span>px solid <span class=\"hljs-hexcolor\">#000</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">-webkit-box-sizing</span>:<span class=\"hljs-value\"> border-box</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">box-sizing</span>:<span class=\"hljs-value\"> border-box</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">200</span>%</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">200</span>%</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">-webkit-transform</span>:<span class=\"hljs-value\"> <span class=\"hljs-function\">scale(<span class=\"hljs-number\">0.5</span>)</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-value\"> <span class=\"hljs-function\">scale(<span class=\"hljs-number\">0.5</span>)</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">-webkit-transform-origin</span>:<span class=\"hljs-value\"> left top</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">transform-origin</span>:<span class=\"hljs-value\"> left top</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n',NULL,NULL),
	(11,11,1500508800000,'javascript,notes','JavaScript高级程序设计----面向对象（1）','JavaScript高级程序设计----面向对象笔记第一弹','<h1 id=\"-\">理解对象</h1>\n<h2 id=\"-\">一、最简单的创建对象</h2>\n<h3 id=\"1-object-\">1.创建Object对象实例</h3>\n<pre><code><span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\nperson.name = <span class=\"hljs-string\">\"Nicholas\"</span>;\nperson.age = <span class=\"hljs-number\">29</span>;\nperson.job = <span class=\"hljs-string\">\"Software Engineer\"</span>;\nperson.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    alert(<span class=\"hljs-keyword\">this</span>.name);\n};\n</code></pre><h3 id=\"2-\">2.字面量创建对象</h3>\n<pre><code><span class=\"hljs-keyword\">var</span> person = {\n    name: <span class=\"hljs-string\">\"Nicholas\"</span>,\n    age: <span class=\"hljs-number\">29</span>,\n    job: <span class=\"hljs-string\">\"Software Engineer\"</span>,\n    sayName: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n        alert(<span class=\"hljs-keyword\">this</span>.name);\n    }\n};\n</code></pre><h2 id=\"-\">二、属性类型</h2>\n<p>ECMAScript 中有两种属性：数据属性和访问器属性；只有在内部才使用的特性，js中无法直接访问；</p>\n<h3 id=\"1-\">1.数据属性</h3>\n<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的<br>特性。</p>\n<ul>\n<li>[[Configurable]] ：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true 。</li>\n<li>[[Enumerable]] ：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true 。</li>\n<li>[[Writable]] ：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true 。</li>\n<li>[[Value]] ：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined 。</li>\n</ul>\n<p>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法。这个方法<br>接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属<br>性必须是： configurable 、 enumerable 、 writable 和 value 。设置其中的一或多个值，可以修改<br>对应的特性值。例如：</p>\n<pre><code>var person = {};\n<span class=\"hljs-constant\">Object</span>.defineProperty(person, <span class=\"hljs-string\">\"name\"</span>, {\n    <span class=\"hljs-symbol\">writable:</span> <span class=\"hljs-keyword\">false</span>,\n    <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-string\">\"Nicholas\"</span>\n});\nalert(person.name); <span class=\"hljs-regexp\">//</span><span class=\"hljs-string\">\"Nicholas\"</span>\nperson.name = <span class=\"hljs-string\">\"Greg\"</span>;\nalert(person.name); <span class=\"hljs-regexp\">//</span><span class=\"hljs-string\">\"Nicholas\"</span>\n</code></pre><h3 id=\"2-\">2.访问器属性</h3>\n<p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。<br>在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用<br>setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。</p>\n<ul>\n<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true 。</li>\n<li>[[Enumerable]] ：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 true 。</li>\n<li>[[Get]] ：在读取属性时调用的函数。默认值为 undefined 。</li>\n<li>[[Set]] ：在写入属性时调用的函数。默认值为 undefined 。<br>访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。<pre><code><span class=\"hljs-keyword\">var</span> book = {\n  _year: <span class=\"hljs-number\">2004</span>,\n  edition: <span class=\"hljs-number\">1</span>\n};\nObject.defineProperty(book, <span class=\"hljs-string\">\"year\"</span>, {\n  <span class=\"hljs-keyword\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>._year;\n  },\n  <span class=\"hljs-keyword\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(newValue)</span>{</span>\n       <span class=\"hljs-keyword\">if</span> (newValue &gt; <span class=\"hljs-number\">2004</span>) {\n           <span class=\"hljs-keyword\">this</span>._year = newValue;\n           <span class=\"hljs-keyword\">this</span>.edition += newValue - <span class=\"hljs-number\">2004</span>;\n      }\n  }\n});\nbook.year = <span class=\"hljs-number\">2005</span>;\nalert(book.edition); <span class=\"hljs-comment\">//2</span>\n</code></pre></li>\n</ul>\n<h2 id=\"-\">三、定义多个属性</h2>\n<p>Object.defineProperties() 方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>\n<pre><code><span class=\"hljs-keyword\">var</span> book = {};\nObject.defineProperties(book, {\n    _year: {\n        value: <span class=\"hljs-number\">2004</span>\n    },\n    edition: {\n        value: <span class=\"hljs-number\">1</span>\n    },\n    year: {\n        <span class=\"hljs-keyword\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>._year;\n        }\n    },\n    <span class=\"hljs-keyword\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(newValue)</span>{</span>\n         <span class=\"hljs-keyword\">if</span> (newValue &gt; <span class=\"hljs-number\">2004</span>) {\n             <span class=\"hljs-keyword\">this</span>._year = newValue;\n             <span class=\"hljs-keyword\">this</span>.edition += newValue - <span class=\"hljs-number\">2004</span>;\n        }\n    }\n});\n</code></pre><h2 id=\"-\">四、读取属性的特性</h2>\n<p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法，可以取得给定属性的描述<br>符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果<br>是访问器属性，这个对象的属性有 configurable 、 enumerable 、 get 和 set ；如果是数据属性，这<br>个对象的属性有 configurable 、 enumerable 、 writable 和 value 。</p>\n',NULL,NULL),
	(12,12,1500595200000,'javascript,notes','JavaScript高级程序设计----面向对象（2）','JavaScript高级程序设计----面向对象笔记第二弹','<h1 id=\"-\">创建对象</h1>\n<h2 id=\"-\">一、工厂模式</h2>\n<p>封装一个函数，函数内部创建对象，添加属性方法并返回对象。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createPerson</span><span class=\"hljs-params\">(name, age, job)</span>{</span>\n    <span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n        alert(<span class=\"hljs-keyword\">this</span>.name);\n    };\n    <span class=\"hljs-keyword\">return</span> o;\n}\n<span class=\"hljs-keyword\">var</span> person1 = createPerson(<span class=\"hljs-string\">\"Nicholas\"</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-string\">\"Software Engineer\"</span>);\n<span class=\"hljs-keyword\">var</span> person2 = createPerson(<span class=\"hljs-string\">\"Greg\"</span>, <span class=\"hljs-number\">27</span>, <span class=\"hljs-string\">\"Doctor\"</span>);\n</code></pre><h2 id=\"-\">二、构造函数模式</h2>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age, job)</span>{</span>\n    <span class=\"hljs-keyword\">this</span>.name = name;\n    <span class=\"hljs-keyword\">this</span>.age = age;\n    <span class=\"hljs-keyword\">this</span>.job = job;\n    <span class=\"hljs-keyword\">this</span>.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n        alert(<span class=\"hljs-keyword\">this</span>.name);\n    };\n}\n<span class=\"hljs-keyword\">var</span> person1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"Nicholas\"</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-string\">\"Software Engineer\"</span>);\n<span class=\"hljs-keyword\">var</span> person2 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"Greg\"</span>, <span class=\"hljs-number\">27</span>, <span class=\"hljs-string\">\"Doctor\"</span>);\n</code></pre><p>与工厂模式相比：1.没有显式地创建对象；2.直接将属性方法赋值给this；3.没有return语句<br><strong>构造函数函数名以大写字母开头；<br>要实例化构造函数，需要使用new操作符；</strong><br>new操作符实例化过程:</p>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋值给这个新对象(this指向了新对象)；</li>\n<li>执行构造函数中的代码（为对象添加属性和方法）；</li>\n<li>返回新对象</li>\n</ol>\n<p>构造函数的缺点：<br>每个方法在每个实例上都会重新创建；如以下代码所示：<br><code>alert(person1.sayName == person2.sayName); //false</code></p>\n<h2 id=\"-\">三、原型模式</h2>\n<p>我们创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向一个对象，<br>而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以<br>让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是<br>可以将这些信息直接添加到原型对象中。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">()</span>{</span>\n}\nPerson.prototype.name = <span class=\"hljs-string\">\"Nicholas\"</span>;\nPerson.prototype.age = <span class=\"hljs-number\">29</span>;\nPerson.prototype.job = <span class=\"hljs-string\">\"Software Engineer\"</span>;\nPerson.prototype.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    alert(<span class=\"hljs-keyword\">this</span>.name);\n};\n<span class=\"hljs-keyword\">var</span> person1 = <span class=\"hljs-keyword\">new</span> Person();\nperson1.sayName(); <span class=\"hljs-comment\">//\"Nicholas\"</span>\n<span class=\"hljs-keyword\">var</span> person2 = <span class=\"hljs-keyword\">new</span> Person();\nperson2.sayName(); <span class=\"hljs-comment\">//\"Nicholas\"</span>\nalert(person1.sayName == person2.sayName); <span class=\"hljs-comment\">//true</span>\n</code></pre><p><strong>使用 isPrototypeOf() 方法测试指示对象是否存在于另一个对象的原型链中</strong><br><strong>使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型</strong><br><strong>使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中</strong><br><strong>如果在实例中添加和原型中同名的属性，会访问实例中的属性，但实例中的属性不会覆盖原型中的同名属性；<br>使用delete操作符可以完全删除实例中的属性，从而能够重新访问到原型中的属性；</strong></p>\n<h3 id=\"in-\">in操作符</h3>\n<p>in 操作符会在通过对象能够访问给定属性时返回 true ，无论该属性存在于实例中还是原型中。<br>同时使用in操作符和hasOwnProperty()方法就可以确定该属性到底是存在于对象中，还是存在于<br>原型中，如下所示。</p>\n<pre><code>function hasPrototypeProperty(<span class=\"hljs-keyword\">object</span>, name){\n    <span class=\"hljs-keyword\">return</span> !<span class=\"hljs-keyword\">object</span>.hasOwnProperty(name) &amp;&amp; (name <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">object</span>);\n}\n</code></pre><p>原型模式的缺点：1.省略了构造函数传递初始化参数，导致所有实例在默认情况下都取得相同的属性值。2.所有实例共享原型的属性，对引用类型（数组，对象）的属性来说，当一个实例改变属性值时，所有实例都将得到改变后的属性值。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">()</span>{</span>\n}\nPerson.prototype = {\n    constructor: Person,\n    name : <span class=\"hljs-string\">\"Nicholas\"</span>,\n    age : <span class=\"hljs-number\">29</span>,\n    job : <span class=\"hljs-string\">\"Software Engineer\"</span>,\n    friends : [<span class=\"hljs-string\">\"Shelby\"</span>, <span class=\"hljs-string\">\"Court\"</span>],\n    sayName : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        alert(<span class=\"hljs-keyword\">this</span>.name);\n    }\n};\n<span class=\"hljs-keyword\">var</span> person1 = <span class=\"hljs-keyword\">new</span> Person();\n<span class=\"hljs-keyword\">var</span> person2 = <span class=\"hljs-keyword\">new</span> Person();\nperson1.friends.push(<span class=\"hljs-string\">\"Van\"</span>);\nalert(person1.friends); <span class=\"hljs-comment\">//\"Shelby,Court,Van\"</span>\nalert(person2.friends); <span class=\"hljs-comment\">//\"Shelby,Court,Van\"</span>\nalert(person1.friends === person2.friends); <span class=\"hljs-comment\">//true</span>\n</code></pre><h2 id=\"-\">四、组合使用构造函数和原型模式</h2>\n<p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age, job)</span>{</span>\n    <span class=\"hljs-keyword\">this</span>.name = name;\n    <span class=\"hljs-keyword\">this</span>.age = age;\n    <span class=\"hljs-keyword\">this</span>.job = job;\n    <span class=\"hljs-keyword\">this</span>.friends = [<span class=\"hljs-string\">\"Shelby\"</span>, <span class=\"hljs-string\">\"Court\"</span>];\n}\nPerson.prototype = {\n    constructor : Person,\n    sayName : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n        alert(<span class=\"hljs-keyword\">this</span>.name);\n    }\n}\n<span class=\"hljs-keyword\">var</span> person1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"Nicholas\"</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-string\">\"Software Engineer\"</span>);\n<span class=\"hljs-keyword\">var</span> person2 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"Greg\"</span>, <span class=\"hljs-number\">27</span>, <span class=\"hljs-string\">\"Doctor\"</span>);\nperson1.friends.push(<span class=\"hljs-string\">\"Van\"</span>);\nalert(person1.friends); <span class=\"hljs-comment\">//\"Shelby,Count,Van\"</span>\nalert(person2.friends); <span class=\"hljs-comment\">//\"Shelby,Count\"</span>\nalert(person1.friends === person2.friends); <span class=\"hljs-comment\">//false</span>\nalert(person1.sayName === person2.sayName); <span class=\"hljs-comment\">//true</span>\n</code></pre><h2 id=\"-\">五、动态原型模式</h2>\n<p>动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age, job)</span>{</span>\n    <span class=\"hljs-comment\">//属性</span>\n    <span class=\"hljs-keyword\">this</span>.name = name;\n    <span class=\"hljs-keyword\">this</span>.age = age;\n    <span class=\"hljs-keyword\">this</span>.job = job;\n    <span class=\"hljs-comment\">// 方法</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span>.sayName != <span class=\"hljs-string\">\"function\"</span>){\n        Person.prototype.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n            alert(<span class=\"hljs-keyword\">this</span>.name);\n        };\n    }\n}\n<span class=\"hljs-keyword\">var</span> friend = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"Nicholas\"</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-string\">\"Software Engineer\"</span>);\nfriend.sayName();\n</code></pre><p><strong>可以使用 instanceof 操作符确定它的类型。</strong></p>\n<h2 id=\"-\">六、寄生构造函数模式</h2>\n<p>通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。<br><strong>除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。</strong></p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age, job)</span>{</span>\n    <span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n        alert(<span class=\"hljs-keyword\">this</span>.name);\n    };\n    <span class=\"hljs-keyword\">return</span> o;\n}\n<span class=\"hljs-keyword\">var</span> friend = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"Nicholas\"</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-string\">\"Software Engineer\"</span>);\nfriend.sayName(); <span class=\"hljs-comment\">//\"Nicholas\"</span>\n</code></pre><p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SpecialArray</span><span class=\"hljs-params\">()</span>{</span>\n    <span class=\"hljs-comment\">//创建数组</span>\n    <span class=\"hljs-keyword\">var</span> values = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>();\n    <span class=\"hljs-comment\">//添加值</span>\n    values.push.apply(values, <span class=\"hljs-built_in\">arguments</span>);\n    <span class=\"hljs-comment\">//添加方法</span>\n    values.toPipedString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.join(<span class=\"hljs-string\">\"|\"</span>);\n    };\n    <span class=\"hljs-comment\">//返回数组</span>\n    <span class=\"hljs-keyword\">return</span> values;\n}\n<span class=\"hljs-keyword\">var</span> colors = <span class=\"hljs-keyword\">new</span> SpecialArray(<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>);\nalert(colors.toPipedString()); <span class=\"hljs-comment\">//\"red|blue|green\"</span>\n</code></pre><p>构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。</p>\n<h2 id=\"-\">七、稳妥构造函数模式</h2>\n<p>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new ），或者在防止数据被其他应用程序（如 Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this ；二是不使用 new 操作符调用构造函数。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age, job)</span>{</span>\n    <span class=\"hljs-comment\">//创建要返回的对象</span>\n    <span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>();\n    <span class=\"hljs-comment\">//可以在这里定义私有变量和函数</span>\n    <span class=\"hljs-comment\">//添加方法</span>\n    o.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n        alert(name);\n    };\n    <span class=\"hljs-comment\">//返回对象</span>\n    <span class=\"hljs-keyword\">return</span> o;\n}\n<span class=\"hljs-keyword\">var</span> friend = Person(<span class=\"hljs-string\">\"Nicholas\"</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-string\">\"Software Engineer\"</span>);\nfriend.sayName(); <span class=\"hljs-comment\">//\"Nicholas\"</span>\n</code></pre><p><strong>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</strong></p>\n',NULL,NULL),
	(13,13,1500768000000,'javascript,notes','JavaScript高级程序设计----面向对象（3）','JavaScript高级程序设计----面向对象笔记第三弹','<h1 id=\"-\">继承</h1>\n<h2 id=\"-\">一、原型链</h2>\n<pre><code>                <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SuperType</span><span class=\"hljs-params\">()</span> {</span>\n            <span class=\"hljs-keyword\">this</span>.property = <span class=\"hljs-literal\">true</span>;\n        }\n        SuperType.prototype.getSuperValue = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.property;\n        };\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SubType</span><span class=\"hljs-params\">()</span> {</span>\n            <span class=\"hljs-keyword\">this</span>.subproperty = <span class=\"hljs-literal\">false</span>;\n        }\n        <span class=\"hljs-comment\">//继承了 SuperType</span>\n        SubType.prototype = <span class=\"hljs-keyword\">new</span> SuperType();\n        SubType.prototype.getSubValue = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.subproperty;\n        };\n        <span class=\"hljs-keyword\">var</span> instance = <span class=\"hljs-keyword\">new</span> SubType();\n        console.log(instance.getSuperValue()); <span class=\"hljs-comment\">//true</span>\n</code></pre><p> SubType 继承了 SuperType ，而继承是通过创建 SuperType 的实例，并将该实例赋给SubType.prototype 实现的。<br>缺点：<br>1.</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SuperType</span><span class=\"hljs-params\">()</span>{</span>\n    <span class=\"hljs-keyword\">this</span>.colors = [<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>];\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SubType</span><span class=\"hljs-params\">()</span>{</span>\n}\n<span class=\"hljs-comment\">//继承了 SuperType</span>\nSubType.prototype = <span class=\"hljs-keyword\">new</span> SuperType();\n<span class=\"hljs-keyword\">var</span> instance1 = <span class=\"hljs-keyword\">new</span> SubType();\ninstance1.colors.push(<span class=\"hljs-string\">\"black\"</span>);\nalert(instance1.colors); <span class=\"hljs-comment\">//\"red,blue,green,black\"</span>\n<span class=\"hljs-keyword\">var</span> instance2 = <span class=\"hljs-keyword\">new</span> SubType();\nalert(instance2.colors); <span class=\"hljs-comment\">//\"red,blue,green,black\"</span>\n</code></pre><p>2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>\n<h2 id=\"-\">二、借用构造函数</h2>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SuperType</span><span class=\"hljs-params\">(name)</span>{</span>\n    <span class=\"hljs-keyword\">this</span>.colors = [<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>];\n    <span class=\"hljs-keyword\">this</span>.name = name;\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SubType</span><span class=\"hljs-params\">()</span>{</span>\n    <span class=\"hljs-comment\">// 继承了 SuperType</span>\n    SuperType.call(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"Nicholas\"</span>);<span class=\"hljs-comment\">//可以向超类型构造函数传递参数</span>\n    <span class=\"hljs-comment\">//实例属性</span>\n    <span class=\"hljs-keyword\">this</span>.age = <span class=\"hljs-number\">29</span>;\n}\n<span class=\"hljs-keyword\">var</span> instance1 = <span class=\"hljs-keyword\">new</span> SubType();\ninstance1.colors.push(<span class=\"hljs-string\">\"black\"</span>);\nalert(instance1.colors); <span class=\"hljs-comment\">//\"red,blue,green,black\";</span>\nalert(instance1.name); <span class=\"hljs-comment\">//\"Nicholas\";</span>\n<span class=\"hljs-keyword\">var</span> instance2 = <span class=\"hljs-keyword\">new</span> SubType();\nalert(instance2.colors); <span class=\"hljs-comment\">//\"red,blue,green\"</span>\n</code></pre><p>缺点：方法都在构造函数中定义，即函数无法复用；</p>\n<h2 id=\"-\">三、组合继承</h2>\n<p>组合继承：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SuperType</span><span class=\"hljs-params\">(name)</span>{</span>\n    <span class=\"hljs-keyword\">this</span>.name = name;\n    <span class=\"hljs-keyword\">this</span>.colors = [<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>];\n}\nSuperType.prototype.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    alert(<span class=\"hljs-keyword\">this</span>.name);\n};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SubType</span><span class=\"hljs-params\">(name, age)</span>{</span>\n    <span class=\"hljs-comment\">//继承属性</span>\n    SuperType.call(<span class=\"hljs-keyword\">this</span>, name);\n    <span class=\"hljs-keyword\">this</span>.age = age;\n}\n<span class=\"hljs-comment\">//继承方法</span>\nSubType.prototype = <span class=\"hljs-keyword\">new</span> SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    alert(<span class=\"hljs-keyword\">this</span>.age);\n};\n<span class=\"hljs-keyword\">var</span> instance1 = <span class=\"hljs-keyword\">new</span> SubType(<span class=\"hljs-string\">\"Nicholas\"</span>, <span class=\"hljs-number\">29</span>);\ninstance1.colors.push(<span class=\"hljs-string\">\"black\"</span>);\nalert(instance1.colors); <span class=\"hljs-comment\">//\"red,blue,green,black\"</span>\ninstance1.sayName(); <span class=\"hljs-comment\">//\"Nicholas\";</span>\ninstance1.sayAge(); <span class=\"hljs-comment\">//29</span>\n<span class=\"hljs-keyword\">var</span> instance2 = <span class=\"hljs-keyword\">new</span> SubType(<span class=\"hljs-string\">\"Greg\"</span>, <span class=\"hljs-number\">27</span>);\nalert(instance2.colors); <span class=\"hljs-comment\">//\"red,blue,green\"</span>\ninstance2.sayName(); <span class=\"hljs-comment\">//\"Greg\";</span>\ninstance2.sayAge(); <span class=\"hljs-comment\">//27</span>\n</code></pre><p><strong>是JavaScript 中最常用的继承模式。而且， instanceof 和 isPrototypeOf() 也能够用于识别基于组合继承创建的对象</strong>。</p>\n<h2 id=\"-\">四、原型式继承</h2>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">object</span><span class=\"hljs-params\">(o)</span>{</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">F</span><span class=\"hljs-params\">()</span>{</span>}  <span class=\"hljs-comment\">//创建一个临时的构造函数</span>\n    F.prototype = o;  <span class=\"hljs-comment\">//将传入的对象作为构造函数的原型</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> F();  <span class=\"hljs-comment\">//返回临时构造函数的实例</span>\n}\n</code></pre><p>例子：</p>\n<pre><code>var person = {\n    name: <span class=\"hljs-string\">\"Nicholas\"</span>,\n    friends: [<span class=\"hljs-string\">\"Shelby\"</span>, <span class=\"hljs-string\">\"Court\"</span>, <span class=\"hljs-string\">\"Van\"</span>]\n}<span class=\"hljs-comment\">;</span>\nvar anotherPerson = object(person)<span class=\"hljs-comment\">;</span>\nanotherPerson<span class=\"hljs-preprocessor\">.name</span> = <span class=\"hljs-string\">\"Greg\"</span><span class=\"hljs-comment\">;</span>\nanotherPerson<span class=\"hljs-preprocessor\">.friends</span><span class=\"hljs-preprocessor\">.push</span>(<span class=\"hljs-string\">\"Rob\"</span>)<span class=\"hljs-comment\">;</span>\nvar yetAnotherPerson = object(person)<span class=\"hljs-comment\">;</span>\nyetAnotherPerson<span class=\"hljs-preprocessor\">.name</span> = <span class=\"hljs-string\">\"Linda\"</span><span class=\"hljs-comment\">;</span>\nyetAnotherPerson<span class=\"hljs-preprocessor\">.friends</span><span class=\"hljs-preprocessor\">.push</span>(<span class=\"hljs-string\">\"Barbie\"</span>)<span class=\"hljs-comment\">;</span>\nalert(person<span class=\"hljs-preprocessor\">.friends</span>)<span class=\"hljs-comment\">; //\"Shelby,Court,Van,Rob,Barbie\"</span>\n</code></pre><p><strong>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</strong></p>\n<h2 id=\"-\">五、寄生式继承</h2>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createAnother</span><span class=\"hljs-params\">(original)</span>{</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">clone</span> = object(original); <span class=\"hljs-comment\">//通过调用函数创建一个新对象</span>\n    <span class=\"hljs-keyword\">clone</span>.sayHi = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span> <span class=\"hljs-comment\">//以某种方式来增强这个对象</span>\n        alert(<span class=\"hljs-string\">\"hi\"</span>);\n    };\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">clone</span>; <span class=\"hljs-comment\">//返回这个对象</span>\n}\n</code></pre><pre><code><span class=\"hljs-keyword\">var</span> person = {\n    name: <span class=\"hljs-string\">\"Nicholas\"</span>,\n    friends: [<span class=\"hljs-string\">\"Shelby\"</span>, <span class=\"hljs-string\">\"Court\"</span>, <span class=\"hljs-string\">\"Van\"</span>]\n};\n<span class=\"hljs-keyword\">var</span> anotherPerson = createAnother(person);\nanotherPerson.sayHi(); <span class=\"hljs-comment\">//\"hi\"</span>\n</code></pre><h2 id=\"-\">六、寄生组合继承</h2>\n<p>组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SuperType</span><span class=\"hljs-params\">(name)</span>{</span>\n    <span class=\"hljs-keyword\">this</span>.name = name;\n    <span class=\"hljs-keyword\">this</span>.colors = [<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>];\n}\nSuperType.prototype.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    alert(<span class=\"hljs-keyword\">this</span>.name);\n};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SubType</span><span class=\"hljs-params\">(name, age)</span>{</span>\n    SuperType.call(<span class=\"hljs-keyword\">this</span>, name); <span class=\"hljs-comment\">// 第二次调用 SuperType()</span>\n    <span class=\"hljs-keyword\">this</span>.age = age;\n}\nSubType.prototype = <span class=\"hljs-keyword\">new</span> SuperType(); <span class=\"hljs-comment\">// 第一次调用 SuperType()</span>\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\nalert(<span class=\"hljs-keyword\">this</span>.age);\n};\n</code></pre><p><strong>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。</strong></p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">inheritPrototype</span><span class=\"hljs-params\">(subType, superType)</span>{</span>\n    <span class=\"hljs-keyword\">var</span> prototype = object(superType.prototype); <span class=\"hljs-comment\">//创建对象</span>\n    prototype.constructor = subType; <span class=\"hljs-comment\">//增强对象</span>\n    subType.prototype = prototype; <span class=\"hljs-comment\">//指定对象</span>\n}\n</code></pre><pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SuperType</span><span class=\"hljs-params\">(name)</span>{</span>\n    <span class=\"hljs-keyword\">this</span>.name = name;\n    <span class=\"hljs-keyword\">this</span>.colors = [<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>];\n}\nSuperType.prototype.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    alert(<span class=\"hljs-keyword\">this</span>.name);\n};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SubType</span><span class=\"hljs-params\">(name, age)</span>{</span>\n    SuperType.call(<span class=\"hljs-keyword\">this</span>, name);\n    <span class=\"hljs-keyword\">this</span>.age = age;\n}\ninheritPrototype(SubType, SuperType);\nSubType.prototype.sayAge = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    alert(<span class=\"hljs-keyword\">this</span>.age);\n};\n</code></pre><p>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和 isPrototypeOf() 。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>\n',NULL,NULL),
	(14,14,1501718400000,'css,less','less的使用','本文主要记录使用less过程中的笔记','<h1 id=\"-\">less的使用</h1>\n<p><strong>变量</strong></p>\n<pre><code class=\"lang-css\"><span class=\"hljs-at_rule\">@<span class=\"hljs-keyword\">nice-blue:</span> #<span class=\"hljs-number\">5</span>B83AD</span>;\n<span class=\"hljs-at_rule\">@<span class=\"hljs-keyword\">light-blue:</span> @nice-blue + #<span class=\"hljs-number\">111</span></span>;\n\n<span class=\"hljs-id\">#header</span> <span class=\"hljs-rules\">{ <span class=\"hljs-rule\"><span class=\"hljs-attribute\">color</span>:<span class=\"hljs-value\"> @light-blue</span></span>; <span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<p>css：<br><code>#header { color: #6c94be; }</code></p>\n<p><strong>混合</strong><br><code>.bordered{ border-bottom: 1px solid #ccc; }</code>  //定义class<br>//调用class</p>\n<pre><code class=\"lang-css\"><span class=\"hljs-id\">#menu</span> <span class=\"hljs-tag\">a</span> {\n  <span class=\"hljs-attribute\">color</span><span class=\"hljs-value\">: <span class=\"hljs-hexcolor\">#111</span>;</span>\n  <span class=\"hljs-class\">.bordered</span>;\n}\n<span class=\"hljs-class\">.post</span> <span class=\"hljs-tag\">a</span> {\n  <span class=\"hljs-attribute\">color</span><span class=\"hljs-value\">: red;</span>\n  <span class=\"hljs-class\">.bordered</span>;\n}\n</code></pre>\n<p><strong>带参数的混合</strong></p>\n<pre><code class=\"lang-css\"><span class=\"hljs-built_in\">.</span>border<span class=\"hljs-attribute\">-radius</span> (@radius) {   <span class=\"hljs-comment\">//参数也可设置默认值 @radius: 5px</span>\n  border<span class=\"hljs-attribute\">-radius</span>: @radius;\n  <span class=\"hljs-attribute\">-moz</span><span class=\"hljs-attribute\">-border</span><span class=\"hljs-attribute\">-radius</span>: @radius;\n  <span class=\"hljs-attribute\">-webkit</span><span class=\"hljs-attribute\">-border</span><span class=\"hljs-attribute\">-radius</span>: @radius;\n}\n</code></pre>\n<pre><code class=\"lang-css\"><span class=\"hljs-preprocessor\">#header {</span>\n  <span class=\"hljs-preprocessor\">.border</span>-radius(<span class=\"hljs-number\">4</span>px)<span class=\"hljs-comment\">;</span>\n}\n<span class=\"hljs-preprocessor\">.button</span> {\n  <span class=\"hljs-preprocessor\">.border</span>-radius(<span class=\"hljs-number\">6</span>px)<span class=\"hljs-comment\">;  </span>\n}\n\n</code></pre>\n<p><strong>模式匹配</strong><br>有以下设置：</p>\n<pre><code class=\"lang-css\">.mixin (dark, <span class=\"hljs-variable\">@color</span>) {\n  <span class=\"hljs-keyword\">color</span>: darken(<span class=\"hljs-variable\">@color</span>, <span class=\"hljs-number\">10</span><span class=\"hljs-variable\">%)</span>;\n}\n.mixin (light, <span class=\"hljs-variable\">@color</span>) {\n  <span class=\"hljs-keyword\">color</span>: lighten(<span class=\"hljs-variable\">@color</span>, <span class=\"hljs-number\">10</span><span class=\"hljs-variable\">%)</span>;\n}\n.mixin (<span class=\"hljs-variable\">@_</span>, <span class=\"hljs-variable\">@color</span>) {\n  display: block;\n}\n</code></pre>\n<p>根据 @switch 的值来匹配不同的样式：</p>\n<pre><code class=\"lang-css\"><span class=\"hljs-variable\">@switch</span><span class=\"hljs-symbol\">:</span> light;\n\n.<span class=\"hljs-keyword\">class</span> {\n  .mixin(<span class=\"hljs-variable\">@switch</span>, <span class=\"hljs-comment\">#888);</span>\n}\n</code></pre>\n<p>css输出：</p>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.class</span> <span class=\"hljs-rules\">{\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">color</span>:<span class=\"hljs-value\"> <span class=\"hljs-hexcolor\">#a2a2a2</span></span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">display</span>:<span class=\"hljs-value\"> block</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<p><strong>引导</strong><br><strong>根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用</strong></p>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.mixin</span> (<span class=\"hljs-at_rule\">@a)<span class=\"hljs-preprocessor\"> when</span> (<span class=\"hljs-function\">lightness(@a)</span> &gt;=<span class=\"hljs-preprocessor\"> 50</span>%) {</span>\n  <span class=\"hljs-attribute\">background-color</span><span class=\"hljs-value\">: black;</span>\n}\n<span class=\"hljs-class\">.mixin</span> (<span class=\"hljs-at_rule\">@a)<span class=\"hljs-preprocessor\"> when</span> (<span class=\"hljs-function\">lightness(@a)</span> &lt;<span class=\"hljs-preprocessor\"> 50</span>%) {</span>\n  <span class=\"hljs-attribute\">background-color</span><span class=\"hljs-value\">: white;</span>\n}\n<span class=\"hljs-class\">.mixin</span> (<span class=\"hljs-at_rule\">@a) {</span>\n  <span class=\"hljs-attribute\">color</span><span class=\"hljs-value\">: @a;</span>\n}\n</code></pre>\n<pre><code class=\"lang-css\"><span class=\"hljs-preprocessor\">.class</span>1 { <span class=\"hljs-preprocessor\">.mixin</span>(<span class=\"hljs-preprocessor\">#ddd) }</span>\n<span class=\"hljs-preprocessor\">.class</span>2 { <span class=\"hljs-preprocessor\">.mixin</span>(<span class=\"hljs-preprocessor\">#555) }</span>\n</code></pre>\n<p>css输出：</p>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.class1</span> <span class=\"hljs-rules\">{\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> black</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">color</span>:<span class=\"hljs-value\"> <span class=\"hljs-hexcolor\">#ddd</span></span></span>;\n<span class=\"hljs-rule\">}</span></span>\n<span class=\"hljs-class\">.class2</span> <span class=\"hljs-rules\">{\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> white</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">color</span>:<span class=\"hljs-value\"> <span class=\"hljs-hexcolor\">#555</span></span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<p><strong>嵌套</strong></p>\n<pre><code class=\"lang-css\"><span class=\"hljs-id\">#header</span> {\n  <span class=\"hljs-attribute\">color</span><span class=\"hljs-value\">: black;</span>\n\n  <span class=\"hljs-class\">.navigation</span> {\n    <span class=\"hljs-attribute\">font-size</span><span class=\"hljs-value\">: <span class=\"hljs-number\">12</span>px;</span>\n  }\n  <span class=\"hljs-class\">.logo</span> {\n    <span class=\"hljs-attribute\">width</span><span class=\"hljs-value\">: <span class=\"hljs-number\">300</span>px;</span>\n    &amp;<span class=\"hljs-pseudo\">:hover</span> { <span class=\"hljs-attribute\">text-decoration</span><span class=\"hljs-value\">: none }\n  }\n}</span>\n</code></pre>\n<p><strong>运算</strong></p>\n<pre><code class=\"lang-css\"><span class=\"hljs-variable\">@base</span>: <span class=\"hljs-number\">5</span><span class=\"hljs-variable\">%;</span>\n<span class=\"hljs-variable\">@filler</span>: <span class=\"hljs-variable\">@base</span> * <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-variable\">@other</span>: <span class=\"hljs-variable\">@base</span> + <span class=\"hljs-variable\">@filler</span>;\n\n<span class=\"hljs-keyword\">color</span>: #<span class=\"hljs-number\">888</span> / <span class=\"hljs-number\">4</span>;\nbackground-<span class=\"hljs-keyword\">color</span>: <span class=\"hljs-variable\">@base</span>-<span class=\"hljs-keyword\">color</span> + #<span class=\"hljs-number\">111</span>;\nheight: <span class=\"hljs-number\">100</span>% / <span class=\"hljs-number\">2</span> + <span class=\"hljs-variable\">@filler</span>;\n</code></pre>\n<p><code>@var: 1px + 5;</code>  //6px;</p>\n<p><code>border: (@width * 2) solid black;</code></p>\n<p><a href=\"http://www.bootcss.com/p/lesscss/#docs\">http://www.bootcss.com/p/lesscss/#docs</a></p>',NULL,NULL),
	(15,15,1502755200000,'javascript,wechat','微信网页授权 ','本文介绍了微信网页授权获取openid的基本流程','<h1 id=\"-\">微信网页授权</h1>\n<p><strong>用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息</strong><br><strong>注意：开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</strong> </p>\n<p>以snsapi_base为scope发起的网页授权，静默授权；直接进入回调url；<strong>（用户必须先关注公众号）</strong><br>以snsapi_userinfo为scope发起的网页授权，需要用户手动同意，才能获取用户信息，<strong>（无需关注公众号）</strong><br>具体而言，网页授权流程分为四步：</p>\n<h2 id=\"1-code\">1. 引导用户进入授权页面同意授权，获取code</h2>\n<p>引导关注者打开 <code>https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</code>若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。<br>正确链接例子：<br>_scope为snsapi_base_</p>\n<pre><code>https:<span class=\"hljs-regexp\">//open</span>.weixin.qq.com/<span class=\"hljs-keyword\">connect</span>/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https<span class=\"hljs-variable\">%3A</span><span class=\"hljs-variable\">%2F</span><span class=\"hljs-variable\">%2Fchong</span>.qq.com<span class=\"hljs-variable\">%2Fphp</span><span class=\"hljs-variable\">%2Findex</span>.php<span class=\"hljs-variable\">%3Fd</span><span class=\"hljs-variable\">%3D</span><span class=\"hljs-variable\">%26c</span><span class=\"hljs-variable\">%3DwxAdap</span>\nter<span class=\"hljs-variable\">%26m</span><span class=\"hljs-variable\">%3DmobileDeal</span><span class=\"hljs-variable\">%26showwxpaytitle</span><span class=\"hljs-variable\">%3D1</span><span class=\"hljs-variable\">%26vb2ctag</span><span class=\"hljs-variable\">%3D4_2030_5_1194_60</span>&amp;response_type=code&amp;scope=snsapi_bas\ne&amp;<span class=\"hljs-keyword\">state</span>=<span class=\"hljs-number\">123</span><span class=\"hljs-comment\">#wechat_redirect </span>\n</code></pre><p>_scope为snsapi_userinfo_ </p>\n<pre><code><span class=\"hljs-label\">https:</span>//open<span class=\"hljs-preprocessor\">.weixin</span><span class=\"hljs-preprocessor\">.qq</span><span class=\"hljs-preprocessor\">.com</span>/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&amp;redirect_uri=http%<span class=\"hljs-number\">3</span>A%<span class=\"hljs-number\">2</span>F%<span class=\"hljs-number\">2</span>Fnba<span class=\"hljs-preprocessor\">.bluewebgame</span><span class=\"hljs-preprocessor\">.com</span>%<span class=\"hljs-number\">2</span>Foauth_response<span class=\"hljs-preprocessor\">.php</span>&amp;response_type=\ncode&amp;scope=snsapi_userinfo&amp;state=STATE<span class=\"hljs-preprocessor\">#wechat_redirect </span>\n</code></pre><p>_尤其注意：跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。_</p>\n<p>如果用户同意授权，页面将跳转至 <code>redirect_uri/?code=CODE&amp;state=STATE</code>。<br><strong>code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期。</strong> </p>\n<h2 id=\"2-code-access_token-access_token-\">2. 通过code换取网页授权access_token（与基础支持中的access_token不同）</h2>\n<p><strong>尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起。</strong><br>获取code后，请求以下链接获取access_token：  <code>https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</code><br>正确调用返回：</p>\n<pre><code>{ \"<span class=\"hljs-attribute\">access_token</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\"ACCESS_TOKEN\"</span></span>,    \n \"<span class=\"hljs-attribute\">expires_in</span>\":<span class=\"hljs-value\"><span class=\"hljs-number\">7200</span></span>,    \n \"<span class=\"hljs-attribute\">refresh_token</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\"REFRESH_TOKEN\"</span></span>,    \n \"<span class=\"hljs-attribute\">openid</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\"OPENID\"</span></span>,    \n \"<span class=\"hljs-attribute\">scope</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\"SCOPE\"</span> </span>} \n</code></pre><h2 id=\"3-access_token-\">3. 如果需要，开发者可以刷新网页授权access_token，避免过期</h2>\n<p>由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权。<br>获取第二步的refresh_token后，请求以下链接获取access_token：<br><code>https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</code></p>\n<h2 id=\"4-access_token-openid-scope-snsapi_userinfo-\">4. 通过网页授权access_token和openid获取用户基本信息（(需scope为 snsapi_userinfo)）</h2>\n<p>http：GET（请使用https协议） <code>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</code></p>\n<p>正确时返回的JSON数据包如下：</p>\n<pre><code>{   \n \"<span class=\"hljs-attribute\">openid</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\" OPENID\"</span></span>,  \n \"<span class=\"hljs-attribute\"> nickname</span>\": <span class=\"hljs-value\">NICKNAME</span>,   \n \"<span class=\"hljs-attribute\">sex</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\"1\"</span></span>,   \n \"<span class=\"hljs-attribute\">province</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\"PROVINCE\"</span>   \n <span class=\"hljs-string\">\"city\"</span>:<span class=\"hljs-string\">\"CITY\"</span></span>,   \n \"<span class=\"hljs-attribute\">country</span>\":<span class=\"hljs-value\"><span class=\"hljs-string\">\"COUNTRY\"</span></span>,    \n \"<span class=\"hljs-attribute\">headimgurl</span>\":    \n <span class=\"hljs-value\"><span class=\"hljs-string\">\"http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46\"</span></span>,  \n \"<span class=\"hljs-attribute\">privilege</span>\":<span class=\"hljs-value\">[ <span class=\"hljs-string\">\"PRIVILEGE1\"</span> <span class=\"hljs-string\">\"PRIVILEGE2\"</span>]</span>,    \n \"<span class=\"hljs-attribute\">unionid</span>\": <span class=\"hljs-value\"><span class=\"hljs-string\">\"o6_bmasdasdsad6_2sgVt7hMZOPfL\"</span> \n</span>} \n</code></pre>',NULL,NULL),
	(16,16,1503619200000,'tomcat,java','Tomcat安装配置 ','记录搭建java环境','<h1 id=\"-\">Tomcat安装与配置</h1>\n<h2 id=\"jdk-\">jdk配置</h2>\n<ol>\n<li><p>下载java jdk，安装。</p>\n</li>\n<li><p>添加环境变量（系统变量）：<br>名称：  <code>JAVA_HOME</code>  变量值：   <strong>jdk安装路径</strong></p>\n</li>\n<li><p>添加用户变量：<br>名称：  <code>CLASS_PATH</code>   变量值：<code>.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar</code></p>\n</li>\n<li><p>在path中添加  <code>;%JAVA_HOME%\\bin;</code></p>\n</li>\n<li><p>测试配置成功  cmd 中输入 <code>java -version</code>，出现版本号即配置成功</p>\n</li>\n</ol>\n<h2 id=\"tomcat-\">tomcat配置</h2>\n<ol>\n<li><p>下载tomcat，安装</p>\n</li>\n<li><p>添加环境变量（系统变量）：<br>名称：  <code>CATALINA_HOME</code>  变量值：   <strong>tomcat安装路径</strong></p>\n</li>\n<li><p>测试配置成功：<br><code>tomcat\\bin\\startup.bat</code>  开启服务器<br>打开 <a href=\"http://localhost:8080\">http://localhost:8080</a> 出现tomcat迎接页即配置成功</p>\n</li>\n</ol>\n<p><code>tomcat\\bin\\shutdown.bat</code>  关闭服务器</p>',NULL,NULL),
	(17,17,1505088000000,'bug,FAQ','h5页面点击判断是否安装app并打开，否则跳转下载页面','<p><strong>需求描述：在移动端页面中，有一个”购买‘’按钮，若本地安装了 app，则直接打开本地 app，若没有安装，则跳转到 AppStore 或者应用市场。</strong></p>','<h1 id=\"-\">h5页面点击判断是否安装app并打开，否则跳转下载页面</h1>\n<p><strong>需求描述：在移动端页面中，有一个”购买‘’按钮，若本地安装了 app，则直接打开本地 app，若没有安装，则跳转到 AppStore 或者应用市场。</strong></p>\n<h2 id=\"-app-\">如何打开本地 app？</h2>\n<p>首先， <code>ios</code> 与 <code>Android</code> 都支持一种叫做 <code>schema</code> 协议的链接，例如 金华银行的协议为 <code>jhbhttp://xxxxx</code></p>\n<p>激活这个协议有 3 种方式:</p>\n<p>1.直接写在 a 标签中<br>2.location.href<br>3.iframe 跳转</p>\n<p><em>而 location.href 与 iframe 是解决这个需求的关键。</em></p>\n<h2 id=\"-app\">如何判断本地安装了 app</h2>\n<p>目前，我们是无法直接判断本地是否安装了 app，所以我们需要采取其他方式解决这个需求。</p>\n<p>采用设置一个延迟定时器 setTimeout 的方式，第一时间尝试唤起 app，如果 1000ms 没有唤起成功，则默认本地没有安装 app，1000ms 以后，将会触发下载行为。</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> url = {\n  open: <span class=\"hljs-string\">\'app://xxxxx\'</span>,\n  down: <span class=\"hljs-string\">\'xxxxxxxx\'</span>\n}\n<span class=\"hljs-keyword\">var</span> iframe = document.createElement(<span class=\"hljs-string\">\'iframe\'</span>)\n<span class=\"hljs-keyword\">var</span> body = document.body\niframe.style.cssText = <span class=\"hljs-string\">\'display:none;width=0;height=0\'</span>\n<span class=\"hljs-keyword\">var</span> timer = <span class=\"hljs-literal\">null</span>\n\n<span class=\"hljs-comment\">// 立即打开的按钮</span>\n<span class=\"hljs-keyword\">var</span> openapp = document.getElementById(<span class=\"hljs-string\">\'openapp\'</span>)\nopenapp.addEventListener(\n  <span class=\"hljs-string\">\'click\'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n    body.appendChild(iframe)\n    iframe.src = url.open\n    timer = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n      wondow.location.href = url.down\n    }, <span class=\"hljs-number\">500</span>)\n  },\n  <span class=\"hljs-literal\">false</span>\n)\n</code></pre>\n<p>存在问题：</p>\n<p>1.<code>ios9</code> 以上不支持 <code>iframe</code> 跳转 2.跳转到 app，页面也出现下载页面待完善。。。。</p>\n<p>使用 <code>location.href</code> 方法，ios9 以上也可以跳转，延时器中使用两次跳转是因为有些机型是出现提示框“是否打开 app”，两次跳转可以将提示框刷新掉</p>\n<pre><code class=\"lang-js\">window<span class=\"hljs-preprocessor\">.location</span><span class=\"hljs-preprocessor\">.href</span> = URL scheme<span class=\"hljs-comment\">;</span>\nsetTimeout(function(){\n    window<span class=\"hljs-preprocessor\">.location</span><span class=\"hljs-preprocessor\">.href</span> = downloadUrl<span class=\"hljs-comment\">;</span>\n    window<span class=\"hljs-preprocessor\">.location</span><span class=\"hljs-preprocessor\">.href</span> = downloadUrl<span class=\"hljs-comment\">;</span>\n},<span class=\"hljs-number\">2000</span>)<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p><strong>监听页面隐藏事件，清除延时器（存在兼容问题，很多浏览器不支持该事件）</strong></p>\n<pre><code class=\"lang-js\">$(document).on(<span class=\"hljs-string\">\'visibilitychange webkitvisibilitychange\'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n  <span class=\"hljs-keyword\">var</span> tag = document.hidden || document.webkitHidden\n  <span class=\"hljs-keyword\">if</span> (tag) {\n    clearTimeout(timer)\n  }\n})\n\n$(window).on(<span class=\"hljs-string\">\'pagehide\'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n  clearTimeout(timer)\n})\n</code></pre>\n<h2 id=\"-\">目前最完善的解决方案：</h2>\n<blockquote>\n<p>ios 下</p>\n</blockquote>\n<pre><code class=\"lang-js\">window<span class=\"hljs-preprocessor\">.location</span><span class=\"hljs-preprocessor\">.href</span> = link\nsetTimeout(function() {\n  window<span class=\"hljs-preprocessor\">.location</span><span class=\"hljs-preprocessor\">.href</span> = url\n  window<span class=\"hljs-preprocessor\">.location</span><span class=\"hljs-preprocessor\">.href</span> = url\n}, <span class=\"hljs-number\">2000</span>)\n</code></pre>\n<blockquote>\n<p>andriod 下，由于安卓是多任务，应用会进入后台，所以若使用 ios 的方法，则既会跳转 app，也会跳转下载页面。原理： 设置一个运行间隔 20ms，总计运行 100 次的定时器，如果页面一直处于前台，则 100 次跑完，总耗时与 100x20=2000ms 不会有太大差异，但页面在后台运行时，此时间会明显超过 2000ms。可以利用这一点来实现是否成功打开 APP 检测及回调。</p>\n</blockquote>\n<pre><code class=\"lang-js\">window.location.href = link\n<span class=\"hljs-keyword\">var</span> _clickTime = +<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span><span class=\"hljs-params\">(elsTime)</span> {</span>\n  <span class=\"hljs-keyword\">if</span> (elsTime &gt; <span class=\"hljs-number\">3000</span> || document.hidden || document.webkitHidden) {\n  } <span class=\"hljs-keyword\">else</span> {\n    window.location.href = url\n  }\n}\n<span class=\"hljs-comment\">//启动间隔20ms运行的定时器，并检测累计消耗时间是否超过3000ms，超过则结束</span>\n<span class=\"hljs-keyword\">var</span> _count = <span class=\"hljs-number\">0</span>,\n  intHandle\nintHandle = setInterval(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n  _count++\n  <span class=\"hljs-keyword\">var</span> elsTime = +<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>() - _clickTime\n  <span class=\"hljs-keyword\">if</span> (_count &gt;= <span class=\"hljs-number\">100</span> || elsTime &gt; <span class=\"hljs-number\">3000</span>) {\n    clearInterval(intHandle)\n    check(elsTime)\n  }\n}, <span class=\"hljs-number\">20</span>)\n</code></pre>\n',NULL,NULL),
	(18,18,1505779200000,'bug,FAQ','移动端滚动穿透解决方法 ','<p>在一个可滚动的列表页中打开弹窗，底部的页面理论上是不可滚动的，但是当滑动弹窗时，底部页面会跟随滚动，这就是所谓的页面滚动穿透的问题。</p>','<h1 id=\"-\">移动端滚动穿透解决方法</h1>\n<p>在一个可滚动的列表页中打开弹窗，底部的页面理论上是不可滚动的，但是当滑动弹窗时，底部页面会跟随滚动，这就是所谓的页面滚动穿透的问题。</p>\n<p><code>$.smartScroll(container, selectorScrollable);</code><br><strong>依赖Zepto.js或者jQuery.js，其中：<br>container表示委托的浮层容器元素（$包装器对象），或者页面其他比较祖先的元素，但是，非常不建议使用$(document)或者$(document.body)等对象作为委托容器。<br>selectorScrollable表示container中可以滚动的元素的选择器，表示真正的滚动的主体。</strong></p>\n<h2 id=\"css-\">CSS代码：</h2>\n<pre><code><span class=\"hljs-class\">.noscroll</span>,\n<span class=\"hljs-class\">.noscroll</span> <span class=\"hljs-tag\">body</span> <span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">overflow</span>:<span class=\"hljs-value\"> hidden</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n<span class=\"hljs-class\">.noscroll</span> <span class=\"hljs-tag\">body</span> <span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> relative</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre><h2 id=\"js-\">JS代码</h2>\n<pre><code>$.smartScroll = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(container, selectorScrollable)</span> {</span>\n    <span class=\"hljs-comment\">// 如果没有滚动容器选择器，或者已经绑定了滚动时间，忽略</span>\n    <span class=\"hljs-keyword\">if</span> (!selectorScrollable || container.data(<span class=\"hljs-string\">\'isBindScroll\'</span>)) {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-comment\">// 是否是搓浏览器</span>\n    <span class=\"hljs-comment\">// 自己在这里添加判断和筛选</span>\n    <span class=\"hljs-keyword\">var</span> isSBBrowser;\n\n    <span class=\"hljs-keyword\">var</span> data = {\n        posY: <span class=\"hljs-number\">0</span>,\n        maxscroll: <span class=\"hljs-number\">0</span>\n    };\n\n    <span class=\"hljs-comment\">// 事件处理</span>\n    container.on({\n        touchstart: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(event)</span> {</span>\n            <span class=\"hljs-keyword\">var</span> events = event.touches[<span class=\"hljs-number\">0</span>] || event;\n\n            <span class=\"hljs-comment\">// 先求得是不是滚动元素或者滚动元素的子元素</span>\n            <span class=\"hljs-keyword\">var</span> elTarget = $(event.target);\n\n            <span class=\"hljs-keyword\">if</span> (!elTarget.length) {\n                <span class=\"hljs-keyword\">return</span>;    \n            }\n\n            <span class=\"hljs-keyword\">var</span> elScroll;\n\n            <span class=\"hljs-comment\">// 获取标记的滚动元素，自身或子元素皆可</span>\n            <span class=\"hljs-keyword\">if</span> (elTarget.is(selectorScrollable)) {\n                elScroll = elTarget;\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> ((elScroll = elTarget.parents(selectorScrollable)).length == <span class=\"hljs-number\">0</span>) {\n                elScroll = <span class=\"hljs-literal\">null</span>;\n            }\n\n            <span class=\"hljs-keyword\">if</span> (!elScroll) {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            <span class=\"hljs-comment\">// 当前滚动元素标记</span>\n            data.elScroll = elScroll;\n\n            <span class=\"hljs-comment\">// 垂直位置标记</span>\n            data.posY = events.pageY;\n            data.scrollY = elScroll.scrollTop();\n            <span class=\"hljs-comment\">// 是否可以滚动</span>\n            data.maxscroll = elScroll[<span class=\"hljs-number\">0</span>].scrollHeight - elScroll[<span class=\"hljs-number\">0</span>].clientHeight;\n        },\n        touchmove: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n            <span class=\"hljs-comment\">// 如果不足于滚动，则禁止触发整个窗体元素的滚动</span>\n            <span class=\"hljs-keyword\">if</span> (data.maxscroll &lt;= <span class=\"hljs-number\">0</span> || isSBBrowser) {\n                <span class=\"hljs-comment\">// 禁止滚动</span>\n                event.preventDefault();\n            }\n            <span class=\"hljs-comment\">// 滚动元素</span>\n            <span class=\"hljs-keyword\">var</span> elScroll = data.elScroll;\n            <span class=\"hljs-comment\">// 当前的滚动高度</span>\n            <span class=\"hljs-keyword\">var</span> scrollTop = elScroll.scrollTop();\n\n            <span class=\"hljs-comment\">// 现在移动的垂直位置，用来判断是往上移动还是往下</span>\n            <span class=\"hljs-keyword\">var</span> events = event.touches[<span class=\"hljs-number\">0</span>] || event;\n            <span class=\"hljs-comment\">// 移动距离</span>\n            <span class=\"hljs-keyword\">var</span> distanceY = events.pageY - data.posY;\n\n            <span class=\"hljs-keyword\">if</span> (isSBBrowser) {\n                elScroll.scrollTop(data.scrollY - distanceY);\n                elScroll.trigger(<span class=\"hljs-string\">\'scroll\'</span>);\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            <span class=\"hljs-comment\">// 上下边缘检测</span>\n            <span class=\"hljs-keyword\">if</span> (distanceY &gt; <span class=\"hljs-number\">0</span> &amp;&amp; scrollTop == <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-comment\">// 往上滑，并且到头</span>\n                <span class=\"hljs-comment\">// 禁止滚动的默认行为</span>\n                event.preventDefault();\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            <span class=\"hljs-comment\">// 下边缘检测</span>\n            <span class=\"hljs-keyword\">if</span> (distanceY &lt; <span class=\"hljs-number\">0</span> &amp;&amp; (scrollTop + <span class=\"hljs-number\">1</span> &gt;= data.maxscroll)) {\n                <span class=\"hljs-comment\">// 往下滑，并且到头</span>\n                <span class=\"hljs-comment\">// 禁止滚动的默认行为</span>\n                event.preventDefault();\n                <span class=\"hljs-keyword\">return</span>;\n            }\n        },\n        touchend: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n            data.maxscroll = <span class=\"hljs-number\">0</span>;\n        }    \n    });\n\n    <span class=\"hljs-comment\">// 防止多次重复绑定</span>\n    container.data(<span class=\"hljs-string\">\'isBindScroll\'</span>, <span class=\"hljs-literal\">true</span>);\n};\n</code></pre><blockquote>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2016/12/web-mobile-scroll-prevent-window-js-css/\">解决方法源自</a></p>\n</blockquote>\n',NULL,NULL),
	(19,19,1516665600000,'promise,javascript,es6','Promise对象','本文详细介绍了promise的使用方法以及基本使用场景。','<h1 id=\"-\">Promise对象</h1>\n<h2 id=\"promise\">Promise</h2>\n<h3 id=\"-\">基本概念</h3>\n<blockquote>\n<p>个人理解就是使用同步编程的写法完成异步编程操作。</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">const</span> promise = <span class=\"hljs-keyword\">new</span> Promise<span class=\"hljs-function\"><span class=\"hljs-params\">((resolve, reject) =&gt; {\n    <span class=\"hljs-regexp\">//</span>some asynchronous  code\n    setTimeout(() =&gt; {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'执行完成\'</span>);\n        resolve(<span class=\"hljs-string\">\'some data\'</span>);\n    }, <span class=\"hljs-number\">2000</span>);\n})</span>;</span>\n</code></pre>\n<p><code>Promise</code> 接收一个函数作为参数，函数有两个参数，<code>resolve</code> 和 <code>reject</code> 分别表示异步操作执行后成功的回调函数和失败的回调函数。 </p>\n<p><code>Promise</code> 实例后马上执行。所以通常采用一个函数包含它</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">function</span> runAsync() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Promise<span class=\"hljs-function\"><span class=\"hljs-params\">((resolve, reject) =&gt; {\n        <span class=\"hljs-regexp\">//</span>some asynchronous  code\n        setTimeout(() =&gt; {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'执行完成\'</span>);\n            resolve(<span class=\"hljs-string\">\'some data\'</span>);\n        }, <span class=\"hljs-number\">2000</span>);\n    })</span>;\n}\n<span class=\"hljs-title\">runAsync</span><span class=\"hljs-params\">()</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">((data) =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(data);<span class=\"hljs-regexp\">//</span>可以使用异步操作中的数据\n})</span></span>\n</code></pre>\n<p><code>runAsync()</code> 执行完调用 <code>then</code> 方法，<code>then()</code> 就相当于我们之前写的回调函数。</p>\n<h3 id=\"resolve-reject\">resolve 和 reject</h3>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">function</span> paramTest(){\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Promise<span class=\"hljs-function\"><span class=\"hljs-params\">((resolve, reject) =&gt; {\n        <span class=\"hljs-reserved\">let</span> number = Math.ceil(Math.random() * <span class=\"hljs-number\">10</span>);<span class=\"hljs-regexp\">//</span>生成<span class=\"hljs-number\">1</span>-<span class=\"hljs-number\">10</span>的随机数\n        <span class=\"hljs-keyword\">if</span> (number &lt; <span class=\"hljs-number\">5</span>) {\n            resolve(number);\n        }<span class=\"hljs-keyword\">else</span>{\n            reject(<span class=\"hljs-string\">\'out of range\'</span>);\n        }\n    })</span>\n}\n<span class=\"hljs-title\">paramTest</span><span class=\"hljs-params\">()</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">((number) =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'resolved\'</span>);\n    <span class=\"hljs-built_in\">console</span>.log(number);\n},(reason) =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'rejected\'</span>);\n    <span class=\"hljs-built_in\">console</span>.log(reason);\n})</span></span>\n</code></pre>\n<p><code>Promise</code> 有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）</p>\n<p><code>paramTest()</code> 例子有两种情况：</p>\n<ul>\n<li>当 <code>number &lt; 5</code> 时，我们认为是成功情况，将状态从 <code>pending</code> 变为 <code>fulfilled</code></li>\n<li>当 <code>number &gt;= 5</code> 时，我们认为是失败情况，将状态从 <code>pending</code> 变为 <code>rejected</code></li>\n</ul>\n<blockquote>\n<p>所以<code>paramTest()</code> 的执行结果：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>fulfilled</th>\n<th>rejected</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>resolved</td>\n<td>rejected</td>\n</tr>\n<tr>\n<td>number</td>\n<td>out of range</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"catch-\">catch的用法</h3>\n<blockquote>\n<p>我们继续调用 <code>paramTest</code> 方法举例</p>\n</blockquote>\n<pre><code class=\"lang-js\">paramTest<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">((number) =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'resolved\'</span>);\n    <span class=\"hljs-built_in\">console</span>.log(number);\n    <span class=\"hljs-built_in\">console</span>.log(data); <span class=\"hljs-regexp\">//</span>data为未定义\n},(reason) =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'rejected\'</span>);\n    <span class=\"hljs-built_in\">console</span>.log(reason);\n})</span>.<span class=\"hljs-title\">catch</span><span class=\"hljs-params\">((err) =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(err);\n})</span></span>\n</code></pre>\n<p><code>catch</code> 方法其实就是 <code>.then(null, rejection)</code> 的别名，也是用来处理失败失败的回调函数，但是还有一个作用：当 <code>resolve</code> 回调中如果出现错误了，不会堵塞，会执行 <code>catch</code> 中的回调。</p>\n<h3 id=\"all-\">all的用法</h3>\n<pre><code class=\"lang-js\">const p = Promise.all([p1, p2, p3]);\n\np.<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-constant\">result</span> =&gt; {\n    console.<span class=\"hljs-command\">log</span>(<span class=\"hljs-constant\">result</span>);\n})\n</code></pre>\n<blockquote>\n<p><code>all</code> 方法接收一个数组参数，数组中每一项返回的都是 <code>Promise</code> 对象，只有当 <code>p1, p2, p3</code> 都执行完才会进入 <code>then</code> 回调。<code>p1, p2, p3</code> 返回的数据会以一个数组的形式传到 <code>then</code> 回调中。</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">const</span> p1 = <span class=\"hljs-keyword\">new</span> Promise<span class=\"hljs-function\"><span class=\"hljs-params\">((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(<span class=\"hljs-string\">\'p1\'</span>);\n    }, <span class=\"hljs-number\">1000</span>);\n})</span>\n.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(result =&gt; result)</span>\n.<span class=\"hljs-title\">catch</span><span class=\"hljs-params\">(e =&gt; e)</span>;\n\n<span class=\"hljs-title\">const</span> <span class=\"hljs-title\">p2</span> = <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">Promise</span><span class=\"hljs-params\">((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(<span class=\"hljs-string\">\'p2\'</span>);\n    }, <span class=\"hljs-number\">3000</span>);\n})</span>\n.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(result =&gt; result)</span>\n.<span class=\"hljs-title\">catch</span><span class=\"hljs-params\">(e =&gt; e)</span>;\n\n<span class=\"hljs-title\">Promise</span>.<span class=\"hljs-title\">all</span><span class=\"hljs-params\">([p1, p2])</span>\n.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(result =&gt; <span class=\"hljs-built_in\">console</span>.log(result))</span>\n.<span class=\"hljs-title\">catch</span><span class=\"hljs-params\">(e =&gt; <span class=\"hljs-built_in\">console</span>.log(e))</span>;\n//3秒后输出[\'<span class=\"hljs-title\">p1</span>\', \'<span class=\"hljs-title\">p2</span>\']</span>\n</code></pre>\n<h3 id=\"race-\">race的用法</h3>\n<pre><code class=\"lang-js\">const p = Promise.race([p1, p2, p3]);\n\np.<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-constant\">result</span> =&gt; {\n    console.<span class=\"hljs-command\">log</span>(<span class=\"hljs-constant\">result</span>);\n})\n</code></pre>\n<blockquote>\n<p><code>race</code> 的用法与 <code>all</code> 如出一辙，不同的是 <code>all</code> 方法需要参数的每一项都返回成功了才会执行 <code>then</code>;而 <code>race</code> 则是只要参数中的某一项返回成功就执行 <code>then</code> 回调。</p>\n</blockquote>\n<blockquote>\n<p>以下是 <code>race</code> 的例子，和 <code>all</code> 方法对比，可以看到返回值有很明显的区别。</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">const</span> p1 = <span class=\"hljs-keyword\">new</span> Promise<span class=\"hljs-function\"><span class=\"hljs-params\">((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(<span class=\"hljs-string\">\'p1\'</span>);\n    }, <span class=\"hljs-number\">1000</span>);\n})</span>\n.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(result =&gt; result)</span>\n.<span class=\"hljs-title\">catch</span><span class=\"hljs-params\">(e =&gt; e)</span>;\n\n<span class=\"hljs-title\">const</span> <span class=\"hljs-title\">p2</span> = <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">Promise</span><span class=\"hljs-params\">((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(<span class=\"hljs-string\">\'p2\'</span>);\n    }, <span class=\"hljs-number\">3000</span>);\n})</span>\n.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(result =&gt; result)</span>\n.<span class=\"hljs-title\">catch</span><span class=\"hljs-params\">(e =&gt; e)</span>;\n\n<span class=\"hljs-title\">Promise</span>.<span class=\"hljs-title\">race</span><span class=\"hljs-params\">([p1, p2])</span>\n.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(result =&gt; <span class=\"hljs-built_in\">console</span>.log(result))</span>\n.<span class=\"hljs-title\">catch</span><span class=\"hljs-params\">(e =&gt; <span class=\"hljs-built_in\">console</span>.log(e))</span>;\n//1秒后输出 \'<span class=\"hljs-title\">p1</span>\'</span>\n</code></pre>\n<h3 id=\"-\">两个有用的方法</h3>\n<ul>\n<li><strong>done()</strong></li>\n</ul>\n<blockquote>\n<p>总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>\n</blockquote>\n<pre><code class=\"lang-js\">asyncFunc()\n  <span class=\"hljs-preprocessor\">.then</span>(f1)\n  <span class=\"hljs-preprocessor\">.catch</span>(<span class=\"hljs-built_in\">r1</span>)\n  <span class=\"hljs-preprocessor\">.then</span>(f2)\n  <span class=\"hljs-preprocessor\">.done</span>()<span class=\"hljs-comment\">;</span>\n</code></pre>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">//实现方法</span>\nPromise.prototype.done = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(onFulfilled, onRejected)</span> {</span>\n  this.then(onFulfilled, onRejected)\n    .<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(reason)</span> {</span>\n      <span class=\"hljs-comment\">// 抛出一个全局错误</span>\n      setTimeout(() =&gt; { <span class=\"hljs-keyword\">throw</span> reason }, <span class=\"hljs-number\">0</span>);\n    });\n};\n</code></pre>\n<ul>\n<li><strong>finally()</strong></li>\n</ul>\n<blockquote>\n<p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作(同样也是位于回调链的结尾)。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-regexp\">//</span>实现方法\nPromise.prototype.<span class=\"hljs-keyword\">finally</span> = <span class=\"hljs-reserved\">function</span> (callback) {\n  <span class=\"hljs-reserved\">let</span> P = <span class=\"hljs-keyword\">this</span>.constructor;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">then</span>(\n    value<span class=\"hljs-function\">  =&gt;</span> P.resolve<span class=\"hljs-function\"><span class=\"hljs-params\">(callback())</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(() =&gt; value)</span>,\n    <span class=\"hljs-title\">reason</span> =&gt;</span> P.resolve<span class=\"hljs-function\"><span class=\"hljs-params\">(callback())</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(() =&gt; { <span class=\"hljs-keyword\">throw</span> reason })</span>\n  );\n};</span>\n</code></pre>\n<p><a href=\"https://chenyinkai.github.io/Pages/html/Promise.html\">示例源代码(F12查看)</a><br><a href=\"https://github.com/chenyinkai/resloader\">Promise实践:使用Promise实现图片预加载，并展示加载进度</a></p>\n<p><strong>参考</strong><br><a href=\"http://es6.ruanyifeng.com/#docs/promise\">http://es6.ruanyifeng.com/#docs/promise</a><br><a href=\"http://www.cnblogs.com/lvdabao/p/es6-promise-1.html\">http://www.cnblogs.com/lvdabao/p/es6-promise-1.html</a></p>\n',NULL,NULL),
	(20,20,1517184000000,'vue','vue父子组件通信 ','<code>vue</code>中最强大的莫过于组件功能，那么组件之间是怎么通信的呢？','<h1 id=\"vue-\">vue 父子组件通信</h1>\n<h2 id=\"-\">父 -&gt; 子的数据传递</h2>\n<h3 id=\"-props-\">使用 <code>Props</code> 传递数据</h3>\n<blockquote>\n<p>父组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"parent\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">son</span> <span class=\"hljs-attribute\">:number</span>=<span class=\"hljs-value\">\"num\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">son</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nimport son from <span class=\"hljs-string\">\'./children/son\'</span>\n\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'parent\'</span>,\n  data () {\n    <span class=\"hljs-keyword\">return</span> {\n      num: <span class=\"hljs-number\">1</span>\n    }\n  },\n  components:{\n    son\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>子组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"son\"</span>&gt;</span>\n    </span><span class=\"hljs-expression\">{{<span class=\"hljs-variable\">number</span>}}</span><span class=\"xml\">\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'son\'</span>,\n  props:{\n    number:<span class=\"hljs-built_in\">Number</span>\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span></span>\n</code></pre>\n<p>子组件显示 0</p>\n<h3 id=\"-props\">动态 <code>Props</code></h3>\n<blockquote>\n<p>修改父组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"parent\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">son</span> <span class=\"hljs-attribute\">:number</span>=<span class=\"hljs-value\">\"num\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">son</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nimport son from <span class=\"hljs-string\">\'./children/son\'</span>\n\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'parent\'</span>,\n  data () {\n    <span class=\"hljs-keyword\">return</span> {\n      num: <span class=\"hljs-number\">1</span>\n    }\n  },\n  mounted () {\n    setTimeout(() =&gt; {\n      <span class=\"hljs-keyword\">this</span>.num = <span class=\"hljs-number\">99</span>;\n    }, <span class=\"hljs-number\">3000</span>);\n  },\n  components:{\n    son\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</code></pre>\n<p>子组件先显示 0, 3 秒后显示 99</p>\n<h2 id=\"-\">子 -&gt; 父的数据传递</h2>\n<h3 id=\"-\">自定义事件</h3>\n<blockquote>\n<p>父组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"parent\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">son</span> <span class=\"hljs-attribute\">:number</span>=<span class=\"hljs-value\">\"num\"</span> @<span class=\"hljs-attribute\">reset</span>=<span class=\"hljs-value\">\"resetNum\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">son</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nimport son from <span class=\"hljs-string\">\'./children/son\'</span>\n\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'parent\'</span>,\n  data () {\n    <span class=\"hljs-keyword\">return</span> {\n      num: <span class=\"hljs-number\">0</span>\n    }\n  },\n  mounted () {\n    setTimeout(() =&gt; {\n      <span class=\"hljs-keyword\">this</span>.num = <span class=\"hljs-number\">99</span>;\n    }, <span class=\"hljs-number\">3000</span>);\n  },\n  methods: {\n    resetNum (data) {\n      <span class=\"hljs-keyword\">this</span>.num = data;\n    }\n  },\n  components:{\n    son\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>子组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"son\"</span>&gt;</span>\n    </span><span class=\"hljs-expression\">{{<span class=\"hljs-variable\">number</span>}}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">button</span> @<span class=\"hljs-attribute\">click</span>=<span class=\"hljs-value\">\"reset\"</span>&gt;</span>reset<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'son\'</span>,\n  props:{\n    number:<span class=\"hljs-built_in\">Number</span>\n  },\n  methods: {\n    reset () {\n      <span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">\'reset\'</span>, <span class=\"hljs-number\">0</span>)\n    }\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span></span>\n</code></pre>\n<p>此时, 子组件初始显示 0, 3 秒后显示 99, 点击 <code>reset</code> 重新显示 0</p>\n<h3 id=\"-sync-\">.sync 修饰符</h3>\n<blockquote>\n<p>实现双向数据绑定的语法糖</p>\n</blockquote>\n<blockquote>\n<p>父组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"parent\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">son</span> <span class=\"hljs-attribute\">:number.sync</span>=<span class=\"hljs-value\">\"num\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">son</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nimport son from <span class=\"hljs-string\">\'./children/son\'</span>\n\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'parent\'</span>,\n  data () {\n    <span class=\"hljs-keyword\">return</span> {\n      num: <span class=\"hljs-number\">0</span>\n    }\n  },\n  mounted () {\n    setTimeout(() =&gt; {\n      <span class=\"hljs-keyword\">this</span>.num = <span class=\"hljs-number\">99</span>;\n    }, <span class=\"hljs-number\">3000</span>);\n  },\n  components:{\n    son\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>子组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"son\"</span>&gt;</span>\n    </span><span class=\"hljs-expression\">{{<span class=\"hljs-variable\">number</span>}}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">button</span> @<span class=\"hljs-attribute\">click</span>=<span class=\"hljs-value\">\"reset\"</span>&gt;</span>reset<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'son\'</span>,\n  props:{\n    number:<span class=\"hljs-built_in\">Number</span>\n  },\n  methods: {\n    reset () {\n      <span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">\'update:number\'</span>, <span class=\"hljs-number\">0</span>)\n    }\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span></span>\n</code></pre>\n<p><a href=\"https://cn.vuejs.org/v2/guide/components.html#Prop\">https://cn.vuejs.org/v2/guide/components.html#Prop</a></p>\n',NULL,NULL),
	(21,21,1517529600000,'promise,javascript,es6','实现一个简单版本的Promise','之前我们已经了解了<code>promise</code>的强大之处，那么它的原理是什么呢？本文将会实现一个简单的<code>promise</code>.','<h1 id=\"-\">实现一个简单版本的promise</h1>\n<blockquote>\n<p>简单版本的 <code>Promise</code> 实现，只有 <code>then</code> 方法</p>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MyPromise</span><span class=\"hljs-params\">(executor)</span>{</span>\n    let <span class=\"hljs-keyword\">self</span> = this\n    <span class=\"hljs-keyword\">self</span>.status = <span class=\"hljs-string\">\'pending\'</span> <span class=\"hljs-comment\">// Promise当前的状态</span>\n    <span class=\"hljs-keyword\">self</span>.data = undefined <span class=\"hljs-comment\">// Promise的值</span>\n    <span class=\"hljs-keyword\">self</span>.onResolvedCallback = [] <span class=\"hljs-comment\">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span>\n    <span class=\"hljs-keyword\">self</span>.onRejectedCallback = [] <span class=\"hljs-comment\">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span>\n\n    let resolve = (value) =&gt; {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">self</span>.status === <span class=\"hljs-string\">\'pending\'</span>) {\n            <span class=\"hljs-keyword\">self</span>.status = <span class=\"hljs-string\">\'resolved\'</span>\n            <span class=\"hljs-keyword\">self</span>.data = value\n            <span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">self</span>.onResolvedCallback.length; i++) {\n                <span class=\"hljs-keyword\">self</span>.onResolvedCallback[i](value)\n            }\n        }\n    }\n\n    let reject = (reason) =&gt; {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">self</span>.status === <span class=\"hljs-string\">\'pending\'</span>) {\n            <span class=\"hljs-keyword\">self</span>.status = <span class=\"hljs-string\">\'rejected\'</span>\n            <span class=\"hljs-keyword\">self</span>.data = reason\n            <span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">self</span>.onRejectedCallback.length; i++) {\n                <span class=\"hljs-keyword\">self</span>.onRejectedCallback[i](reason)\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">try</span> { <span class=\"hljs-comment\">// 考虑到执行executor的过程中有可能出错，所以我们用try/catch块给包起来，并且在出错后以catch到的值reject掉这个Promise</span>\n        executor(resolve, reject) <span class=\"hljs-comment\">// 执行executor</span>\n    } <span class=\"hljs-keyword\">catch</span> (e) {\n        reject(e)\n    }\n}\nMyPromise.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(onResolved, onRejected)</span> {</span>\n    let <span class=\"hljs-keyword\">self</span> = this\n    let promise2\n\n    <span class=\"hljs-comment\">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理</span>\n    onResolved = typeof onResolved === <span class=\"hljs-string\">\'function\'</span> ? onResolved : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(value)</span> {</span>\n        <span class=\"hljs-keyword\">return</span> value\n    }\n    onRejected = typeof onRejected === <span class=\"hljs-string\">\'function\'</span> ? onRejected : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(reason)</span> {</span>\n        <span class=\"hljs-keyword\">throw</span> reason\n    }\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">self</span>.status === <span class=\"hljs-string\">\'resolved\'</span>) {\n        <span class=\"hljs-comment\">// 如果promise1(此处即为this/self)的状态已经确定并且是resolved，我们调用onResolved</span>\n        <span class=\"hljs-comment\">// 因为考虑到有可能throw，所以我们将其包在try/catch块里</span>\n        <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(resolve, reject)</span> {</span>\n            <span class=\"hljs-keyword\">try</span> {\n                let result = onResolved(<span class=\"hljs-keyword\">self</span>.data)\n                <span class=\"hljs-keyword\">if</span> (result <span class=\"hljs-keyword\">instanceof</span> Promise) { <span class=\"hljs-comment\">// 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果</span>\n                    result.then(resolve, reject)\n                }\n                resolve(result) <span class=\"hljs-comment\">// 否则，以它的返回值做为promise2的结果</span>\n            } <span class=\"hljs-keyword\">catch</span> (e) {\n                reject(e) <span class=\"hljs-comment\">// 如果出错，以捕获到的错误做为promise2的结果</span>\n            }\n        })\n    }\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">self</span>.status === <span class=\"hljs-string\">\'rejected\'</span>) {\n        <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(resolve, reject)</span> {</span>\n            <span class=\"hljs-keyword\">try</span> {\n                let result = onRejected(<span class=\"hljs-keyword\">self</span>.data)\n                <span class=\"hljs-keyword\">if</span> (result <span class=\"hljs-keyword\">instanceof</span> Promise) {\n                    result.then(resolve, reject)\n                }\n            } <span class=\"hljs-keyword\">catch</span> (e) {\n                reject(e)\n            }\n        })\n    }\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">self</span>.status === <span class=\"hljs-string\">\'pending\'</span>) {\n        <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(resolve, reject)</span> {</span>\n            <span class=\"hljs-keyword\">self</span>.onResolvedCallback.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(value)</span> {</span>\n                <span class=\"hljs-keyword\">try</span> {\n                    let result = onResolved(<span class=\"hljs-keyword\">self</span>.data)\n                    <span class=\"hljs-keyword\">if</span> (result <span class=\"hljs-keyword\">instanceof</span> Promise) {\n                        result.then(resolve, reject)\n                    }\n                } <span class=\"hljs-keyword\">catch</span> (e) {\n                    reject(e)\n                }\n            })\n\n            <span class=\"hljs-keyword\">self</span>.onRejectedCallback.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(reason)</span> {</span>\n                <span class=\"hljs-keyword\">try</span> {\n                    let result = onRejected(<span class=\"hljs-keyword\">self</span>.data)\n                    <span class=\"hljs-keyword\">if</span> (result <span class=\"hljs-keyword\">instanceof</span> Promise) {\n                        result.then(resolve, reject)\n                    }\n                } <span class=\"hljs-keyword\">catch</span> (e) {\n                    reject(e)\n                }\n            })\n        })\n    }\n}\n</code></pre>\n<blockquote>\n<p>测试</p>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-reserved\">const</span> <span class=\"hljs-function\"><span class=\"hljs-title\">MyPromiseTest</span> = <span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise<span class=\"hljs-function\"><span class=\"hljs-params\">((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            <span class=\"hljs-reserved\">let</span> num = Math.random();\n            resolve(num);\n        }, <span class=\"hljs-number\">3000</span>);\n    })</span>\n}\n\n<span class=\"hljs-title\">MyPromiseTest</span><span class=\"hljs-params\">()</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">((result) =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(result);\n})</span></span>\n</code></pre>\n<p>3 秒后输出随机数</p>',NULL,NULL),
	(22,22,1517788800000,'javascript','函数防抖','一个防抖函数','<h1 id=\"-\">函数防抖</h1>\n<blockquote>\n<p>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间</p>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-transposed_variable\">window.</span>onscroll = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'hello world\'</span>);\n};\n</code></pre>\n<p>在窗口滚动过程中会连续打印出很多的 <code>hello world</code></p>\n<blockquote>\n<p>防抖函数</p>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-reserved\">const</span> <span class=\"hljs-function\"><span class=\"hljs-title\">debounce</span> = <span class=\"hljs-params\">(fn, wait = <span class=\"hljs-number\">0</span>)</span> =&gt;</span> {\n    <span class=\"hljs-reserved\">let</span> inDebounce;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-reserved\">function</span> () {\n        <span class=\"hljs-reserved\">const</span> context = <span class=\"hljs-keyword\">this</span>;\n        <span class=\"hljs-reserved\">const</span> args = arguments;\n        clearTimeout(inDebounce);\n        inDebounce = setTimeout<span class=\"hljs-function\"><span class=\"hljs-params\">(() =&gt; fn.apply(context, args), wait)</span>;\n    };\n};</span>\n</code></pre>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-transposed_variable\">window.</span>addEventListener(\n    <span class=\"hljs-string\">\'scroll\'</span>,\n    debounce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'hello world\'</span>);\n    }, <span class=\"hljs-number\">250</span>)\n)\n</code></pre>\n<p>在窗口滚动后 <code>250ms</code> 后执行 <code>console.log(&#39;hello world&#39;)</code></p>\n',NULL,NULL),
	(23,23,1518048000000,'javascript','自定义事件以及移动端长按事件实现','自定义事件以及移动端长按事件实现','<h1 id=\"-\">随便开个头</h1>\n<pre><code class=\"lang-html\"><span class=\"hljs-doctype\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span> <span class=\"hljs-attribute\">lang</span>=<span class=\"hljs-value\">\"en\"</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charset</span>=<span class=\"hljs-value\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"viewport\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"X-UA-Compatible\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"ie=edge\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">style</span>&gt;</span><span class=\"css\">\n        * <span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">padding</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n\n        <span class=\"hljs-tag\">div</span><span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">100</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">100</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> red</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin-bottom</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">20</span>px</span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span>&gt;</span>长按事件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span>&gt;</span>三击事件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\n        <span class=\"hljs-keyword\">let</span> oDiv = document.getElementsByTagName(<span class=\"hljs-string\">\'div\'</span>)[<span class=\"hljs-number\">0</span>];\n        <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-string\">\'\'</span>;\n\n        oDiv.addEventListener(<span class=\"hljs-string\">\'longTap\'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(e)</span> {</span>\n            console.log(e);\n            console.log(<span class=\"hljs-string\">\'长按事件触发\'</span>)\n        }, <span class=\"hljs-literal\">false</span>);\n\n        <span class=\"hljs-keyword\">var</span> event = <span class=\"hljs-keyword\">new</span> CustomEvent(<span class=\"hljs-string\">\'longTap\'</span>, { <span class=\"hljs-string\">\'data\'</span>: <span class=\"hljs-string\">\'detail\'</span> });\n\n        oDiv.ontouchstart = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n            console.log(<span class=\"hljs-string\">\'ontouchstart\'</span>);\n            timer = setTimeout(() =&gt; {\n                console.log(<span class=\"hljs-string\">\'longTap\'</span>); <span class=\"hljs-comment\">//长按状态</span>\n                oDiv.dispatchEvent(event);\n            }, <span class=\"hljs-number\">1000</span>);\n        }\n        oDiv.ontouchmove = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n            console.log(<span class=\"hljs-string\">\'ontouchmove\'</span>);\n            clearTimeout(timer);\n        }\n        oDiv.ontouchend = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n            console.log(<span class=\"hljs-string\">\'ontouchend\'</span>);\n            clearTimeout(timer);\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\">\n        <span class=\"hljs-keyword\">let</span> oDiv1 = document.getElementsByTagName(<span class=\"hljs-string\">\'div\'</span>)[<span class=\"hljs-number\">1</span>];\n        oDiv1.addEventListener(<span class=\"hljs-string\">\'tripleclick\'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(event)</span> {</span>\n            console.log(<span class=\"hljs-string\">\'三击\'</span>)\n        }, <span class=\"hljs-literal\">false</span>);\n\n        <span class=\"hljs-keyword\">var</span> e = <span class=\"hljs-keyword\">new</span> Event(<span class=\"hljs-string\">\'tripleclick\'</span>);\n\n        <span class=\"hljs-keyword\">var</span> counter = <span class=\"hljs-number\">0</span>;\n        oDiv1.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n            setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span> counter = <span class=\"hljs-number\">0</span>; }, <span class=\"hljs-number\">500</span>);\n            <span class=\"hljs-keyword\">if</span> (++counter == <span class=\"hljs-number\">3</span>) {\n                oDiv1.dispatchEvent(e);\n            }\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\n</code></pre>\n',NULL,NULL),
	(24,24,1519516800000,'javascript','复制文本加上版权信息功能实现 ','<p>有些网站为了维护版权信息, 用户在复制完成后, 发现粘帖出来的内容往往都还有一些作者名字之类的版权信息, 那么这样的功能是怎么实现的呢? 其实原理也是非常的简单，就是监听一下剪切板事件.</p>','<h1 id=\"javascript\">复制文本加上版权信息功能实现 </h1>\n<p>有些网站为了维护版权信息, 用户在复制完成后, 发现粘帖出来的内容往往都还有一些作者名字之类的版权信息, 那么这样的功能是怎么实现的呢? 其实原理也是非常的简单，就是监听一下剪切板事件.</p>\n<pre><code class=\"lang-html\"><span class=\"hljs-doctype\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span> <span class=\"hljs-attribute\">lang</span>=<span class=\"hljs-value\">\"en\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charset</span>=<span class=\"hljs-value\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"viewport\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"width=device-width, initial-scale=1.0, user-scalable=no\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"X-UA-Compatible\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"ie=edge\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span>&gt;</span>前端好难学啊<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\n        <span class=\"hljs-keyword\">let</span> oDiv = document.querySelector(<span class=\"hljs-string\">\'div\'</span>);\n        oDiv.oncopy = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(e)</span> {</span> <span class=\"hljs-comment\">// 复制事件</span>\n            e.preventDefault();\n            <span class=\"hljs-keyword\">let</span> copyMsg = window .getSelection() + <span class=\"hljs-string\">\'商业转载请注明出处。\'</span>; <span class=\"hljs-comment\">// window .getSelection() 表示选择的内容</span>\n            e.clipboardData.setData(<span class=\"hljs-string\">\"Text\"</span>, copyMsg); <span class=\"hljs-comment\">// 将复制信息添加到剪切板</span>\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>原理: 监听文本复制事件,　并阻止事件默认行为, <code>window .getSelection()</code> 表示选中的文本内容, 再调用 <code>clipboardData.setData()</code> 方法将修改后的文本添加到剪切板</p>\n</blockquote>\n<blockquote>\n<p>猛戳<a href=\"https://caniuse.com/#search=Clipboard\">这里</a>查看 <code>clipboardData</code> 对象的兼容性 </p>\n</blockquote>\n<p><strong>注意</strong></p>\n<ul>\n<li>在IE中，clipboardData对象是window对象的属性；</li>\n<li>在Chrome、Safari和Firefox 4+中，clipboardData对象是相应event对象的属性。</li>\n</ul>\n',NULL,NULL),
	(25,25,1519603200000,'FAQ','push 到 github远程仓库时，每次都要输入用户名和密码的问题 ','解决<code>push</code> 到 <code>github</code> 远程仓库时，每次都要输入用户名和密码的问题 ','<h1 id=\"github\">push 到 github远程仓库时，每次都要输入用户名和密码的问题 </h1>\n<blockquote>\n<p>原因是使用了 <code>https</code> 方式 <code>push</code></p>\n</blockquote>\n<blockquote>\n<p>使用 <code>git remote -v</code> 查看对应的仓库地址, 如果返回的结果是以下这种格式的, 则是https方式</p>\n</blockquote>\n<pre><code class=\"lang-bash\">origin https://github<span class=\"hljs-preprocessor\">.com</span>/chenyinkai/demo<span class=\"hljs-preprocessor\">.git</span> (fetch)\norigin https://github<span class=\"hljs-preprocessor\">.com</span>/chenyinkai/demo<span class=\"hljs-preprocessor\">.git</span> (<span class=\"hljs-keyword\">push</span>)\n</code></pre>\n<p>下面换成 <code>ssh</code> 方式</p>\n<pre><code class=\"lang-bash\">git remote rm origin\n\ngit remote <span class=\"hljs-keyword\">add</span> origin git@github<span class=\"hljs-preprocessor\">.com</span>:chenyinkai/demo<span class=\"hljs-preprocessor\">.git</span>\n\ngit <span class=\"hljs-keyword\">push</span> origin\n</code></pre>\n<h3 id=\"hexo-push-\">hexo搭建的博客修改 <code>push</code> 方式</h3>\n<blockquote>\n<p>修改 _config.yml 下 repository 的格式</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-label\">repository:</span> git@github<span class=\"hljs-preprocessor\">.com</span>:chenyinkai/chenyinkai<span class=\"hljs-preprocessor\">.github</span><span class=\"hljs-preprocessor\">.io</span><span class=\"hljs-preprocessor\">.git</span>\n</code></pre>\n',NULL,NULL),
	(26,26,1519689600000,'vue','vue非父子组件之间通信 ','<p>之前我们已经对父子组件之间的通信有了一定的理解 #22 ,那么对于非父子组件之间的通信该如何实现呢？</p>','<h1 id=\"vue\">vue非父子组件之间的通信</h1>\n<p>之前我们已经对父子组件之间的通信有了一定的理解 #22 ,那么对于非父子组件之间的通信该如何实现呢？</p>\n<h3 id=\"event-bus\">Event Bus</h3>\n<p>首先, 新建一个 <code>bus.js</code>, 使用一个空的 <code>Vue</code> 实例作为事件总线</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-reserved\">import</span> Vue from <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-reserved\">export</span> <span class=\"hljs-reserved\">default</span> <span class=\"hljs-keyword\">new</span> Vue()\n</code></pre>\n<p>再新建两个组件：</p>\n<blockquote>\n<p><code>a</code> 组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"aa\"</span>&gt;</span>\n    </span><span class=\"hljs-expression\">{{<span class=\"hljs-variable\">msg</span>}}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">button</span> @<span class=\"hljs-attribute\">click</span>=<span class=\"hljs-value\">\"toBus\"</span>&gt;</span>子组件传给兄弟组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nimport Bus from <span class=\"hljs-string\">\"../bus\"</span>;<span class=\"hljs-comment\">// 引入bus.js</span>\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\"aa\"</span>,\n  data() {\n    <span class=\"hljs-keyword\">return</span> {\n      msg: <span class=\"hljs-string\">\"this is aa component\"</span>\n    };\n  },\n  methods: {\n    toBus() {\n      Bus.$emit(<span class=\"hljs-string\">\"on\"</span>, <span class=\"hljs-string\">\"data from aa component\"</span>);<span class=\"hljs-comment\">// 发送 `on` 事件</span>\n    }\n  }\n};\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">style</span> <span class=\"hljs-attribute\">scoped</span>&gt;</span><span class=\"css\">\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">style</span>&gt;</span></span>\n</code></pre>\n<blockquote>\n<p><code>b</code> 组件</p>\n</blockquote>\n<pre><code class=\"lang-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"bb\"</span>&gt;</span>\n      </span><span class=\"hljs-expression\">{{<span class=\"hljs-variable\">msg</span>}}</span><span class=\"xml\">\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nimport Bus from <span class=\"hljs-string\">\"../bus\"</span>;<span class=\"hljs-comment\">// 引入bus.js</span>\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\"bb\"</span>,\n  data() {\n    <span class=\"hljs-keyword\">return</span> {\n      msg: <span class=\"hljs-string\">\"this is bb component\"</span>\n    };\n  },\n  mounted() {\n    Bus.$on(<span class=\"hljs-string\">\"on\"</span>, msg =&gt; { <span class=\"hljs-comment\">// 监听 `on` 事件</span>\n      <span class=\"hljs-keyword\">this</span>.msg = msg;\n    });\n  }\n};\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">style</span> <span class=\"hljs-attribute\">scoped</span>&gt;</span><span class=\"css\">\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">style</span>&gt;</span></span>\n</code></pre>\n<p>最后将 <code>a</code> , <code>b</code> 组件展示出来</p>\n<pre><code class=\"lang-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"hello\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">A</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">A</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">B</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">B</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\nimport A from <span class=\"hljs-string\">\'./a.vue\'</span>\nimport B from <span class=\"hljs-string\">\'./b.vue\'</span>\nexport <span class=\"hljs-keyword\">default</span> {\n  name: <span class=\"hljs-string\">\'HelloWorld\'</span>,\n  components:{\n    A,\n    B\n  }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">style</span> <span class=\"hljs-attribute\">scoped</span>&gt;</span><span class=\"css\">\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">style</span>&gt;</span>\n</code></pre>\n<p>此时点击 <code>a</code> 组件中的按钮，就会发现 <code>b</code> 中的 <code>msg</code> 变成了 <code>data from aa component</code></p>\n<h3 id=\"vuex\">vuex</h3>\n<blockquote>\n<p>在复杂情况下, 就应该考虑使用 <code>vuex</code> 来管理状态了</p>\n</blockquote>\n<p>见 #2  </p>',NULL,NULL),
	(27,27,1519776000000,'web','XSS和CSRF','本文主要介绍<code>XSS</code>和<code>CSRF</code>攻击的基本概念以及前端该怎么防止<code>XSS</code>和<code>CSRF</code>攻击。','<h1 id=\"xss-csrf\">XSS和CSRF</h1>\n<h2 id=\"xss\">XSS</h2>\n<h3 id=\"-\">概念</h3>\n<blockquote>\n<p><code>Cross Site Scripting</code>, 跨站脚本攻击, 主要来源于HTML或JS的代码注入</p>\n</blockquote>\n<p>XSS类型分为3种, 反射型XSS, 存储型XSS, DOM-XSS。</p>\n<ul>\n<li><p>反射型XSS</p>\n<blockquote>\n<p>直接将用户的输入数据展示到页面中, 后台不保存数据, 属于非持久型 <code>XSS</code></p>\n</blockquote>\n</li>\n<li><p>存储型XSS</p>\n<blockquote>\n<p>将用户的输入数据不经过处理直接保存到数据库中, 此时其他用户只要请求数据, 返回的都是 <code>XSS</code> 脚本, 属于持久型 <code>XSS</code></p>\n</blockquote>\n</li>\n<li><p>DOM-XSS</p>\n<blockquote>\n<p>修改页面 <code>DOM</code> 形成 <code>XSS</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"-\">防御措施</h3>\n<ul>\n<li>永远不要相信用户的输入, 对用户输入数据进行过滤</li>\n<li>字符转义</li>\n<li>设置 <code>HttpOnly</code> 防止劫取 <code>Cookie</code></li>\n</ul>\n<h2 id=\"csrf\">CSRF</h2>\n<h3 id=\"-\">概念</h3>\n<blockquote>\n<p><code>Cross Site Request Forgery</code>, 跨站请求伪造, 其原理是借助受害者的 <code>cookie</code> 来骗取服务器的信任, 发出了非用户本意的请求</p>\n</blockquote>\n<h3 id=\"-\">防御措施</h3>\n<ul>\n<li><p>检查 <code>HTTP Referer</code> 字段</p>\n<blockquote>\n<p><code>Referer</code> 用于表示请求来源于哪个地址, 对于非白名单内的来源地址, 都忽略请求</p>\n</blockquote>\n</li>\n<li><p>添加 <code>TOKEN</code> 验证</p>\n</li>\n</ul>\n<p>参考</p>\n<p><a href=\"https://xwjgo.github.io/2017/10/26/XSS%E5%92%8CCSRF/\">https://xwjgo.github.io/2017/10/26/XSS%E5%92%8CCSRF/</a><br><a href=\"http://www.cnblogs.com/imwtr/p/4763457.html\">http://www.cnblogs.com/imwtr/p/4763457.html</a></p>',NULL,NULL),
	(28,28,1520380800000,'mac,tomcat','mac 下 tomcat 安装与启动',NULL,'<h1 id=\"mac-tomcat-\">mac 下 tomcat 安装与启动</h1>\n<h3 id=\"-\">下载</h3>\n<p>通过<a href=\"https://tomcat.apache.org/download-80.cgi\">官网</a>下载 <code>tomcat</code>, 解压</p>\n<h3 id=\"-\">启动</h3>\n<blockquote>\n<p>终端进入 <code>tomcat</code> 的 <code>bin</code> 目录</p>\n</blockquote>\n<blockquote>\n<p>使用 <code>ls -la *.sh</code> 查看 <code>bin</code> 目录下的脚本，其中 <code>startup.sh</code> 用于启动 <code>Tomcat</code>, <code>shutdown.sh</code> 用于关闭 <code>Tomcat</code></p>\n</blockquote>\n<blockquote>\n<p>默认情况下，你是没有权限执行这个操作的，我们需要授权，用 <code>cd..</code>退回上层目录</p>\n</blockquote>\n<blockquote>\n<p>使用 <code>chmod -R u+x ./bin</code> 命令授权，然后再次进入 <code>bin</code> 目录查看 <code>shell</code> 脚本</p>\n</blockquote>\n<blockquote>\n<p>输入 <code>./startup.sh</code> 启动 <code>Tomcat</code></p>\n</blockquote>\n<blockquote>\n<p>浏览器打开 <code>localhost:8080</code>, 如果出现 <code>tomcat</code> 欢迎页面则表示成功启动</p>\n</blockquote>\n',NULL,NULL),
	(29,29,1521072000000,'vue,axios','vue-cli 搭建的项目处理不同环境下请求不同域名的问题 ','<blockquote>\n<p>使用 <code>vue-cli</code> 开发项目过程中, 根据开发环境和正式环境不同, 我们往往需要请求不同域名下的后台接口, 这时候, 该怎么去设置, 达到同一种写法可以根据环境不同而自动切换请求域名呢? 本文将会介绍两种配置方式.</p>\n</blockquote>\n<blockquote>\n<p>本文中所有请求都是使用 <a href=\"https://github.com/axios/axios\">axios</a></p>\n</blockquote>','<h1 id=\"vue-cli-\">vue-cli 搭建的项目处理不同环境下请求不同域名的问题</h1>\n<blockquote>\n<p>使用 <code>vue-cli</code> 开发项目过程中, 根据开发环境和正式环境不同, 我们往往需要请求不同域名下的后台接口, 这时候, 该怎么去设置, 达到同一种写法可以根据环境不同而自动切换请求域名呢? 本文将会介绍两种配置方式.</p>\n</blockquote>\n<blockquote>\n<p>本文中所有请求都是使用 <a href=\"https://github.com/axios/axios\">axios</a></p>\n</blockquote>\n<h2 id=\"-\">一</h2>\n<blockquote>\n<ol>\n<li>修改 <code>config/dev.env.js</code> (开发环境的配置)</li>\n</ol>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-pi\">\'use strict\'</span>\n<span class=\"hljs-keyword\">const</span> merge = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'webpack-merge\'</span>)\n<span class=\"hljs-keyword\">const</span> prodEnv = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'./prod.env\'</span>)\n\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: <span class=\"hljs-string\">\'\"development\"\'</span>,\n  API_HOST: <span class=\"hljs-string\">\'\"http://localhost:3000\"\'</span> <span class=\"hljs-comment\">// 开发环境接口地址(这里是增加的内容)</span>\n})\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>修改 <code>config/prod.env.js</code> (正式环境的配置)</li>\n</ol>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-pi\">\'use strict\'</span>\nmodule.exports = {\n  NODE_ENV: <span class=\"hljs-string\">\'\"production\"\'</span>,\n  API_HOST: <span class=\"hljs-string\">\'\"http://localhost:3000\"\'</span>  <span class=\"hljs-comment\">// 正式环境接口地址(这里是增加的内容)</span>\n}\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>使用 <code>axios</code> 发送请求</li>\n</ol>\n</blockquote>\n<pre><code class=\"lang-javascript\">axios.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">process</span>.env.API_HOST + <span class=\"hljs-string\">\'/api/userData\'</span>)<span class=\"hljs-comment\"> // 请求前加上 `process.env.API_HOST`</span>\n  .<span class=\"hljs-keyword\">then</span>(data =&gt; {\n    console.<span class=\"hljs-built_in\">log</span>(data)\n  })\n</code></pre>\n<h2 id=\"-\">二</h2>\n<blockquote>\n<p>第二种方法主要使用 <code>axios</code> 的创建实例的用法</p>\n</blockquote>\n<blockquote>\n<p>在 <code>main.js</code> 配置 <code>axios</code></p>\n</blockquote>\n<pre><code class=\"lang-javascript\">import axios from <span class=\"hljs-string\">\'axios\'</span>\n\nconst host = process.<span class=\"hljs-keyword\">env</span>.NODE_ENV === <span class=\"hljs-string\">\'development\'</span> ? <span class=\"hljs-string\">\'dev api host\'</span> : <span class=\"hljs-string\">\'prod api host\'</span> <span class=\"hljs-comment\">// 根据 process.env.NODE_ENV 的值判断当前是什么环境</span>\nconst <span class=\"hljs-keyword\">instance</span> = axios.create({\n  baseURL: host\n})\nVue.prototype.<span class=\"hljs-variable\">$http</span> = <span class=\"hljs-keyword\">instance</span>\n</code></pre>\n<blockquote>\n<p>在组件中调用</p>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">this</span>.$http.get(<span class=\"hljs-string\">\'/api/userData\'</span>)\n  .<span class=\"hljs-keyword\">then</span>(data<span class=\"hljs-function\"> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(data)\n  })\n</code></pre>\n',NULL,NULL),
	(30,30,1521244800000,'web,http','http状态码 200(From Cache)和 304(Not Modified)的区别','http状态码 200(From Cache)和 304(Not Modified)的区别','<h1 id=\"http\">http状态码 200(From Cache)和 304(Not Modified)的区别</h1>\n<h3 id=\"200-from-cache-304-not-modified-\"><code>200(From Cache)</code> 和 <code>304(Not Modified)</code> 的区别</h3>\n<blockquote>\n<p><code>200(From Cache)</code> 是指下次加载的资源直接从浏览器的缓存中读取，并没有请求服务端</p>\n</blockquote>\n<blockquote>\n<p><code>304(Not Modified)</code> 当页面刷新或者重新打开的时候，先请求服务端，如果本地缓存的资源没有修改或者更新，则返回 <code>304</code>,加载本地的资源</p>\n</blockquote>\n<blockquote>\n<p><code>Last-Modified</code></p>\n</blockquote>\n<p>浏览器第一次请求资源时，同时有一个 <code>Last-Modified</code> 的属性标记此文件在服务期端最后被修改的时间, 类似于 <code>Last-Modified: Fri, 12 May 2006 18:53:33 GMT</code> 这种格式, 当浏览器第二次再发起请求时, 浏览器会传递一个 <code>If-Modified-Since</code> 报头, 类似于 <code>If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT</code> 这样, 如果服务端的资源没有修改过, 则返回 <code>304(Not Modified)</code></p>',NULL,NULL),
	(31,31,1521504000000,'vue,vue-router','vue-router 的两种模式','本文主要介绍<code>vue-router</code>的两种模式：<code>hash</code>模式和<code>history</code>模式的区别与使用','<h1 id=\"vue-router\">vue-router 的两种模式</h1>\n<h2 id=\"hash-\">hash 模式</h2>\n<blockquote>\n<p><code>vue router</code> 默认模式, 格式类似于 <code>http://localhost:8081/#/register</code>, <code>url</code> 中带有 <code>#</code>, 使用 <code>URL</code> 的 <code>hash</code> 来模拟一个完整的 <code>URL</code>，于是当 <code>URL</code> 改变时，页面不会重新加载。</p>\n</blockquote>\n<h2 id=\"history-\">history 模式</h2>\n<blockquote>\n<p><code>history</code> 模式就和普通的 <code>url</code> 一样, 通过设置 <code>mode</code> 的值可以改变路由模式</p>\n</blockquote>\n<pre><code class=\"lang-javascript\">const router = new VueRouter({\n  mode: <span class=\"hljs-string\">\'history\'</span>,\n  routes: [<span class=\"hljs-keyword\">...</span>]\n})\n</code></pre>\n<p><strong>问题：</strong> 路由为 <code>history</code> 模式下, 当直接输入 <code>url</code> 访问或者刷新页面时, 会出现 <code>404</code>, 所以需要后台配置, 一旦 <code>url</code> 匹配不到任何值, 则返回到 <code>index.html</code> , 也就是<code>APP.vue</code>。</p>\n<pre><code class=\"lang-nginx\">location / {\n  try_files <span class=\"hljs-variable\">$uri</span> <span class=\"hljs-variable\">$uri</span>/ /index.html;\n}\n</code></pre>\n<blockquote>\n<p>以上为 <code>nginx</code> 配置例子</p>\n</blockquote>\n<h2 id=\"-\">参考</h2>\n<p><a href=\"https://router.vuejs.org/zh-cn/essentials/history-mode.html\">https://router.vuejs.org/zh-cn/essentials/history-mode.html</a></p>\n',NULL,NULL),
	(32,32,1521590400000,'javascript,es6','更优雅的处理异步方式 -- async await','本文将会介绍目前解决回调地狱最好的方法--<code>async</code>与<code>await</code>的使用方法。','<h1 id=\"async-await\">async await</h1>\n<h2 id=\"async\">async</h2>\n<blockquote>\n<p>表示函数中存在异步操作</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">// 语法</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">name</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">params</span>)</span> <span class=\"hljs-comment\">{\n  statements\n}</span></span>\n</code></pre>\n<h2 id=\"await\">await</h2>\n<blockquote>\n<p><code>await</code> 只能在 <code>async</code> 函数中使用, 表示需要等待后面的表达式返回结果</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">// 语法</span>\nreturnValue = await <span class=\"hljs-keyword\">expression</span>\n</code></pre>\n<p><strong>注意</strong> <code>await</code> 后面的 <code>Promise</code> 有可能返回的是 <code>rejected</code>, 所以最好把 <code>await</code> 放在 <code>try···catch</code> 中, 方便错误处理</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">try</span> <span class=\"hljs-cell\">{\n    await expression\n  }</span> <span class=\"hljs-keyword\">catch</span> (err) <span class=\"hljs-cell\">{\n    console.log(err)\n  }</span>\n</code></pre>\n<h2 id=\"demo\">demo</h2>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-reserved\">function</span> test() {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Promise<span class=\"hljs-function\"><span class=\"hljs-params\">((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'status:resolve\'</span>)\n      resolve(<span class=\"hljs-string\">\'resolve\'</span>)\n    }, <span class=\"hljs-number\">2000</span>)\n  })</span>\n}\n\n<span class=\"hljs-title\">async</span> <span class=\"hljs-title\">function</span> <span class=\"hljs-title\">async</span><span class=\"hljs-params\">()</span> {\n  <span class=\"hljs-title\">console</span>.<span class=\"hljs-title\">log</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\'asyncfn start\'</span>)</span>\n  <span class=\"hljs-title\">let</span> <span class=\"hljs-title\">result</span> = <span class=\"hljs-title\">await</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span>\n  <span class=\"hljs-title\">console</span>.<span class=\"hljs-title\">log</span><span class=\"hljs-params\">(result)</span>\n}\n\n<span class=\"hljs-title\">async</span><span class=\"hljs-params\">()</span>\n\n<span class=\"hljs-title\">function</span> <span class=\"hljs-title\">testFn</span><span class=\"hljs-params\">(x)</span> {\n  <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">Promise</span><span class=\"hljs-params\">((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(x)\n    }, <span class=\"hljs-number\">2000</span>)\n  })</span>\n}\n\n<span class=\"hljs-title\">async</span> <span class=\"hljs-title\">function</span> <span class=\"hljs-title\">asyncFn</span><span class=\"hljs-params\">(x)</span> {\n  <span class=\"hljs-title\">let</span> <span class=\"hljs-title\">a</span> = <span class=\"hljs-title\">await</span> <span class=\"hljs-title\">testFn</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span>\n  <span class=\"hljs-title\">let</span> <span class=\"hljs-title\">b</span> = <span class=\"hljs-title\">await</span> <span class=\"hljs-title\">testFn</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span>\n  <span class=\"hljs-title\">console</span>.<span class=\"hljs-title\">log</span><span class=\"hljs-params\">(`<span class=\"javascript\">${x}+${a}+${b}</span>`)</span>\n}\n\n<span class=\"hljs-title\">asyncFn</span><span class=\"hljs-params\">(<span class=\"hljs-number\">30</span>)</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(() =&gt; {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'asycnFn finished\'</span>)\n})</span></span>\n</code></pre>\n',NULL,NULL),
	(33,33,1522022400000,'javascript,module','谈谈 JavaScript 的模块化','<p>什么是模块化?</p>\n</blockquote>\n<p>随着代码复杂程度的提高, 项目也变得越来越难维护, <code>JavaScript模块化</code> 也因此油然而生, 本文主要介绍 <code>JavaScript模块化</code> 的一些发展历程。</p>','<h1 id=\"-javascript-\">谈谈 javaScript 的模块化</h1>\n<blockquote>\n<p>什么是模块化?</p>\n</blockquote>\n<p>随着代码复杂程度的提高, 项目也变得越来越难维护, <code>JavaScript模块化</code> 也因此油然而生, 本文主要介绍 <code>JavaScript模块化</code> 的一些发展历程。</p>\n<h2 id=\"-\">传统的开发</h2>\n<blockquote>\n<p>这应该是大家最熟悉的一种加载方式, 但是缺点也比较明显</p>\n</blockquote>\n<ul>\n<li>所有的模块都处于全局作用域下, 容易造成命名冲突</li>\n<li>依赖关系不明显, 比如 <code>main.js</code> 中有使用 <code>jquery</code>, 那么 <code>jquery</code> 就一定要先加载, 但是从引入方式中我们无法直观的察觉依赖关系, 不利于维护</li>\n</ul>\n<pre><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"jquery.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"jquery_scroller.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"bootstarp.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"main.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</code></pre>\n<h2 id=\"commonjs\">CommonJs</h2>\n<blockquote>\n<p>一个文件就是一个模块, 其内部定义的变量, 方法都处于该模块内, 不会对外暴露.</p>\n</blockquote>\n<p>主要语法:</p>\n<ul>\n<li>使用 <code>require</code> 来加载模块</li>\n<li>使用 <code>exports</code> 或者 <code>module.exports</code> 暴露模块中的内容</li>\n</ul>\n<h3 id=\"demo\">demo</h3>\n<ol>\n<li>新建 <code>a.js</code>, 导出 <code>name</code> 和 <code>sayHello</code></li>\n</ol>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-regexp\">//</span> a.js\n<span class=\"hljs-reserved\">const</span> name = <span class=\"hljs-string\">\'Bob\'</span>\n<span class=\"hljs-reserved\">function</span> sayHello(name) {\n  <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">Hello ${name}</span>`)\n}\n<span class=\"hljs-built_in\">module</span>.<span class=\"hljs-built_in\">exports</span>.name = name\n<span class=\"hljs-built_in\">module</span>.<span class=\"hljs-built_in\">exports</span>.sayHello = sayHello\n</code></pre>\n<ol>\n<li>在 <code>b.js</code> 中引入 <code>a</code> 并调用</li>\n</ol>\n<pre><code class=\"lang-javascript\">// b.js\nconst <span class=\"hljs-operator\">a</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'./a\'</span>)\nconst name = <span class=\"hljs-operator\">a</span>.name\nconsole.<span class=\"hljs-built_in\">log</span>(name)<span class=\"hljs-comment\"> // Bob</span>\n<span class=\"hljs-operator\">a</span>.sayHello(name)<span class=\"hljs-comment\"> // Hello Bob</span>\n</code></pre>\n<blockquote>\n<p>由于 <code>CommonJs</code> 是同步加载的模块的, 在服务端(node), 文件都在硬盘上, 所以同步加载也无所谓, 但是在浏览器端, 同步加载就体验不好了. 所以 <code>CommonJs</code> 主要使用于 <code>node</code> 环境下.</p>\n</blockquote>\n<h2 id=\"amd\">AMD</h2>\n<blockquote>\n<p><code>AMD</code> 全称为 <code>Asynchromous Module Definition(异步模块定义)</code>, 实现了异步加载模块. <code>require.js</code> 实现了 <code>AMD</code> 规范</p>\n</blockquote>\n<p>主要语法:</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-function\">require([module], callback)</span> <span class=\"hljs-comment\">// 导入</span>\n\n<span class=\"hljs-function\">define(id, [depends], callback)</span> <span class=\"hljs-comment\">// 导出模块</span>\n</code></pre>\n<h3 id=\"demo\">demo</h3>\n<ol>\n<li>新建 <code>a.js</code>, 输入以下内容</li>\n</ol>\n<pre><code class=\"lang-javascript\">define(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n  <span class=\"hljs-keyword\">let</span> alertName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(str)</span> {</span>\n    alert(<span class=\"hljs-string\">\'I am \'</span> + str)\n  }\n  <span class=\"hljs-keyword\">let</span> alertAge = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(num)</span> {</span>\n    alert(<span class=\"hljs-string\">\'I am \'</span> + num + <span class=\"hljs-string\">\' years old\'</span>)\n  }\n  <span class=\"hljs-keyword\">return</span> {\n    alertName: alertName,\n    alertAge: alertAge\n  }\n})\n</code></pre>\n<ol>\n<li>在 <code>test.html</code> 中调用 <code>a</code> 模块</li>\n</ol>\n<pre><code class=\"lang-html\"><span class=\"hljs-doctype\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span> <span class=\"hljs-attribute\">lang</span>=<span class=\"hljs-value\">\"en\"</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charset</span>=<span class=\"hljs-value\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"viewport\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"X-UA-Compatible\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"ie=edge\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"./require.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"javascript\">\n        <span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">\'a\'</span>], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(alert)</span> {</span>\n            alert.alertName(<span class=\"hljs-string\">\'JohnZhu\'</span>)\n            alert.alertAge(<span class=\"hljs-number\">21</span>)\n        })\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\n</code></pre>\n<p>能够异步加载模块, 适合在浏览器中运行, 但是不能够按需加载, 必须提前加载模块</p>\n<h2 id=\"cmd\">CMD</h2>\n<blockquote>\n<p><code>CMD规范</code> 是阿里的玉伯提出, <code>sea.js</code> 实现。 实现了按需加载</p>\n</blockquote>\n<p>与 <code>AMD</code> 的区别:</p>\n<ul>\n<li>对于依赖的模块 <code>AMD</code> 提前执行，而 <code>CMD</code> 是延迟执行</li>\n<li><code>CMD</code> 推崇依赖就近, <code>AMD</code> 推崇依赖前置</li>\n</ul>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">// AMD</span>\n<span class=\"hljs-function\">define([<span class=\"hljs-string\">\'./a\'</span>, <span class=\"hljs-string\">\'./b\'</span>], <span class=\"hljs-function\">function(a, b)</span> {\n  a.<span class=\"hljs-function\">doSomething()</span>\n  b.<span class=\"hljs-function\">doSomething()</span>\n})</span>\n<span class=\"hljs-comment\">// CMD</span>\n<span class=\"hljs-function\">define(<span class=\"hljs-function\">function(require, exports, module)</span> {\n  var a = <span class=\"hljs-function\">require(<span class=\"hljs-string\">\'./a\'</span>)</span>\n  a.<span class=\"hljs-function\">doSomething()</span>\n  var b = <span class=\"hljs-function\">require(<span class=\"hljs-string\">\'./b\'</span>)</span>\n  b.<span class=\"hljs-function\">doSomething()</span>\n})</span>\n</code></pre>\n<h2 id=\"es6\">ES6</h2>\n<blockquote>\n<p><code>ES6</code> 模块化方案是最规范的方案, 未来也是主流, 对于我们来说也是经常使用与熟悉的. 不过现在的浏览器还不兼容, 使用需要 <code>babel</code> 转码</p>\n</blockquote>\n<ul>\n<li>使用 <code>export</code> 导出模块</li>\n<li>使用 <code>import</code> 导入模块</li>\n</ul>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>\n<span class=\"hljs-keyword\">import</span> { mapState, mapMutations, mapActions } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vuex\'</span>\n\nexport default {\n  created() {\n    console.log(<span class=\"hljs-string\">\'Hello World\'</span>)\n  }\n}\n</code></pre>\n<h2 id=\"-\">参考</h2>\n<p><a href=\"http://www.hangge.com/blog/cache/detail_1686.html\">http://www.hangge.com/blog/cache/detail_1686.html</a><br><a href=\"https://www.imooc.com/article/20057\">https://www.imooc.com/article/20057</a></p>',NULL,NULL),
	(34,34,1522368000000,'javascript','图片的上传与压缩','前端如何处理图片压缩？','<h1 id=\"-\">图片上传以及压缩</h1>\n<blockquote>\n<p>上传图片按钮</p>\n</blockquote>\n<pre><code class=\"lang-html\">&lt;input <span class=\"hljs-keyword\">type</span>=<span class=\"hljs-string\">\"file\"</span> name=<span class=\"hljs-string\">\"img\"</span> id=<span class=\"hljs-string\">\"imgUpload\"</span> accept=<span class=\"hljs-string\">\"image/jpeg, image/png, image/jpg, image/gif\"</span> onchange=<span class=\"hljs-string\">\"uploadImg(this)\"</span>&gt;\n</code></pre>\n<blockquote>\n<p>图片上传</p>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">uploadImg</span><span class=\"hljs-params\">(imgUrl)</span> {</span>\n    <span class=\"hljs-comment\">//判断是否支持FileReader</span>\n    <span class=\"hljs-keyword\">if</span> (window.FileReader) {\n        <span class=\"hljs-keyword\">var</span> reader = <span class=\"hljs-keyword\">new</span> FileReader();\n    } <span class=\"hljs-keyword\">else</span> {\n        alert(<span class=\"hljs-string\">\"您的设备不支持图片预览功能，如需该功能请升级您的设备！\"</span>);\n    }\n\n    <span class=\"hljs-comment\">//获取文件</span>\n    <span class=\"hljs-keyword\">var</span> file = imgUrl.files[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">var</span> picType = file.name.substring(file.name.lastIndexOf(<span class=\"hljs-string\">\".\"</span>) + <span class=\"hljs-number\">1</span>, file.name.length); <span class=\"hljs-comment\">//获取图片的后缀名</span>\n    <span class=\"hljs-keyword\">var</span> imageType = <span class=\"hljs-regexp\">/^image\\//</span>;\n    <span class=\"hljs-comment\">//是否是图片</span>\n    <span class=\"hljs-keyword\">if</span> (!imageType.test(file.type)) {\n        alert(<span class=\"hljs-string\">\"请选择图片！\"</span>);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-comment\">//读取完成</span>\n    reader.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(e)</span> {</span>\n        console.log(e.target.result)\n    };\n    reader.readAsDataURL(file);\n}\n</code></pre>\n<blockquote>\n<p>图片压缩</p>\n</blockquote>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> canvas = document.createElement(<span class=\"hljs-string\">\"canvas\"</span>);\n<span class=\"hljs-keyword\">var</span> ctx = canvas.getContext(<span class=\"hljs-string\">\'2d\'</span>);\n<span class=\"hljs-keyword\">var</span> tCanvas = document.createElement(<span class=\"hljs-string\">\"canvas\"</span>);\n<span class=\"hljs-keyword\">var</span> tctx = tCanvas.getContext(<span class=\"hljs-string\">\"2d\"</span>);\n<span class=\"hljs-keyword\">var</span> maxsize = <span class=\"hljs-number\">100</span> * <span class=\"hljs-number\">1024</span>;\n\n<span class=\"hljs-comment\">// 参数 img 为 &lt;img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAE...\"&gt; 这种格式</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">compress</span><span class=\"hljs-params\">(img)</span> {</span>\n    <span class=\"hljs-keyword\">var</span> initSize = img.src.length;\n    <span class=\"hljs-keyword\">var</span> width = img.width;\n    <span class=\"hljs-keyword\">var</span> height = img.height;\n    <span class=\"hljs-comment\">// 如果图片大于四百万像素，计算压缩比并将大小压至400万以下</span>\n    <span class=\"hljs-keyword\">var</span> ratio;\n    <span class=\"hljs-keyword\">if</span> ((ratio = width * height / <span class=\"hljs-number\">4000000</span>) &gt; <span class=\"hljs-number\">1</span>) {\n        ratio = <span class=\"hljs-built_in\">Math</span>.sqrt(ratio);\n        width /= ratio;\n        height /= ratio;\n    } <span class=\"hljs-keyword\">else</span> {\n        ratio = <span class=\"hljs-number\">1</span>;\n    }\n    canvas.width = width;\n    canvas.height = height;\n    <span class=\"hljs-comment\">// 铺底色</span>\n    ctx.fillStyle = <span class=\"hljs-string\">\"#fff\"</span>;\n    ctx.fillRect(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, canvas.width, canvas.height);\n    <span class=\"hljs-comment\">// 如果图片像素大于100万则使用瓦片绘制</span>\n    <span class=\"hljs-keyword\">var</span> count;\n    <span class=\"hljs-keyword\">if</span> ((count = width * height / <span class=\"hljs-number\">1000000</span>) &gt; <span class=\"hljs-number\">1</span>) {\n        count = ~~(<span class=\"hljs-built_in\">Math</span>.sqrt(count) + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 计算要分成多少块瓦片</span>\n        <span class=\"hljs-comment\">// 计算每块瓦片的宽和高</span>\n        <span class=\"hljs-keyword\">var</span> nw = ~~(width / count);\n        <span class=\"hljs-keyword\">var</span> nh = ~~(height / count);\n        tCanvas.width = nw;\n        tCanvas.height = nh;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; count; i++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; count; j++) {\n                tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, nw, nh);\n                ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);\n            }\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        ctx.drawImage(img, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, width, height);\n    }\n    <span class=\"hljs-comment\">// 进行最小压缩</span>\n    <span class=\"hljs-keyword\">var</span> ndata = canvas.toDataURL(<span class=\"hljs-string\">\'image/jpeg\'</span>, <span class=\"hljs-number\">0.1</span>);\n    tCanvas.width = tCanvas.height = canvas.width = canvas.height = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">return</span> ndata; <span class=\"hljs-comment\">// 返回压缩后的数据 格式: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAE...</span>\n}\n</code></pre>\n',NULL,NULL),
	(35,35,1522627200000,'javascript,es6','arguments 与 剩余参数(...args) 的区别','arguments 与 剩余参数(...args) 的区别','<h1 id=\"arguments-args-\">arguments 与 剩余参数(...args) 的区别</h1>\n<h2 id=\"-\">区别</h2>\n<ul>\n<li><code>arguments</code> 为类数组, 只有 <code>length</code> 属性; 剩余参数为数组, 可使用全部数组的方法</li>\n<li><code>arguments</code> 包含所有函数实参, 剩余参数只包含没有对应形参的实参</li>\n<li><code>arguments</code> 具有一些特别的属性(callee)</li>\n</ul>\n<h2 id=\"examples\">examples</h2>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(a, <span class=\"hljs-rest_arg\">...args</span>)</span> {</span>\n  console.log(a) <span class=\"hljs-comment\">// 1</span>\n  console.log(arguments) <span class=\"hljs-comment\">// [1, 2, 3]</span>\n  console.log(Array.isArray(arguments)) <span class=\"hljs-comment\">// false</span>\n  console.log(Array.prototype.slice.call(arguments)) <span class=\"hljs-comment\">// [1, 2, 3]</span>\n  console.log(Array.isArray(Array.prototype.slice.call(arguments))) <span class=\"hljs-comment\">//true</span>\n  console.log(args) <span class=\"hljs-comment\">// [2, 3]</span>\n}\n\ntest(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n</code></pre>\n<h2 id=\"arguments-\">arguments转数组</h2>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">arguments</span>);\n<span class=\"hljs-keyword\">var</span> args = [...arguments];\n</code></pre>\n',NULL,NULL),
	(36,36,1523318400000,'css','vertical-align 的使用','<p>在 <code>segmentfault</code> 看到这样一个<a href=\"https://jsfiddle.net/qvbtqav7/4/\">问题</a>, 问两个 <code>display: inline-block;</code> 的元素为什么不能对齐显示。 于是想到了使用 <code>vertical-align</code> 来解决。</p>','<h1 id=\"vertical-align-\">vertical-align 的使用</h1>\n<p>在 <code>segmentfault</code> 看到这样一个<a href=\"https://jsfiddle.net/qvbtqav7/4/\">问题</a>, 问两个 <code>display: inline-block;</code> 的元素为什么不能对齐显示。 于是想到了使用 <code>vertical-align</code> 来解决。</p>\n<blockquote>\n<p><code>vertical-align</code> 仅适用于内联和表格单元格元素, 以下是两种常见用法</p>\n</blockquote>\n<h2 id=\"-\">图片与文字的居中</h2>\n<pre><code class=\"lang-html\"><span class=\"hljs-doctype\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span> <span class=\"hljs-attribute\">lang</span>=<span class=\"hljs-value\">\"en\"</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charset</span>=<span class=\"hljs-value\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"viewport\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"X-UA-Compatible\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"ie=edge\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">style</span>&gt;</span><span class=\"css\">\n        * <span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">padding</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n\n        <span class=\"hljs-tag\">div</span> <span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">500</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">padding-left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">30</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> aqua</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">100</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">line-height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">100</span>px</span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n\n        <span class=\"hljs-tag\">img</span> <span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">80</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">80</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">vertical-align</span>:<span class=\"hljs-value\"> middle</span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n\n        <span class=\"hljs-tag\">span</span> <span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">14</span>px</span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">img</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"http://img1.gtimg.com/0/70/7064/706481_1800x1900_0.jpg\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">span</span>&gt;</span>文字居中<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">span</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\n</code></pre>\n<h2 id=\"-display-inline-block-\">使 <code>display: inline-block;</code> 元素对齐显示</h2>\n<pre><code class=\"lang-html\"><span class=\"hljs-doctype\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span> <span class=\"hljs-attribute\">lang</span>=<span class=\"hljs-value\">\"en\"</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charset</span>=<span class=\"hljs-value\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"viewport\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"X-UA-Compatible\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"ie=edge\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">style</span>&gt;</span><span class=\"css\">\n        * <span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">padding</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n\n        <span class=\"hljs-class\">.a</span>,\n        <span class=\"hljs-class\">.b</span> <span class=\"hljs-rules\">{\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">display</span>:<span class=\"hljs-value\"> inline-block</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">200</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">200</span>px</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">border</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">1</span>px solid red</span></span>;\n            <span class=\"hljs-rule\"><span class=\"hljs-attribute\">vertical-align</span>:<span class=\"hljs-value\"> middle</span></span>;\n        <span class=\"hljs-rule\">}</span></span>\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"a\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"b\"</span>&gt;</span>ahjlfchvg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\n</code></pre>\n',NULL,NULL),
	(37,37,1523404800000,'linux,vim','vim 常用命令 ','<p>最近阿里云搞活动，于是入手了个服务器，记录一下操作过程中的一些常用 <code>vim</code> 命令。</p>','<h1 id=\"vim-\">vim 常用命令</h1>\n<blockquote>\n<p>最近阿里云搞活动，于是入手了个服务器，记录一下操作过程中的一些常用 <code>vim</code> 命令。</p>\n</blockquote>\n<h2 id=\"-\">编辑状态</h2>\n<p>a / i    进入编辑状态<br>esc      退出编辑</p>\n<h2 id=\"-\">退出, 保存</h2>\n<p>:q       退出<br>:q!      强制退出<br>:w       保存<br>:wq      保存退出</p>\n<h2 id=\"-\">删除</h2>\n<p>x        删除光标所在位置<br>dd       删除整行, 剪切<br>dw       删除单词(光标在单词首位)</p>\n<h2 id=\"-\">复制</h2>\n<p>yy      复制整行<br>yw      复制单词</p>\n<h2 id=\"-\">粘贴</h2>\n<p>p       粘贴</p>\n<h2 id=\"-\">撤销</h2>\n<p>u       撤销上一次, u3 撤销三次ß</p>\n<h2 id=\"-\">光标操作</h2>\n<p>gg      跳到首行<br>G       跳到末行<br>nG      跳到指定行，如 3g 跳到第三行<br>:set nu       显示文件行数</p>\n<h2 id=\"-\">查找</h2>\n<p>/      直接输入斜杠符号，然后接要查找的字符串，比如：<code>/apple</code>，然后回车确定<br>n      在搜索到结果之后，可以用<code>n</code>键来往下看下一个匹配到的字符串，或者用<code>N</code>来往上查找，记得之前先按回车哦</p>',NULL,NULL),
	(38,38,1524009600000,'vue,nginx','nginx配置多个vue项目','<h2 id=\"-\">需求</h2>\n<p><code>nginx</code> 下配置多个 <code>vue</code> 项目，或者说非根目录下的配置</p>','<h1 id=\"nginx-vue-\">nginx配置多个vue项目</h1>\n<h2 id=\"-\">需求</h2>\n<p><code>nginx</code> 下配置多个 <code>vue</code> 项目，或者说非根目录下的配置</p>\n<blockquote>\n<p>举例:</p>\n</blockquote>\n<ul>\n<li>blog: <code>https://www.yoursite.com/blog</code></li>\n<li>test: <code>https://www.yoursite.com/test</code></li>\n</ul>\n<h2 id=\"vue-\">vue项目中配置</h2>\n<blockquote>\n<p><code>vue-router</code> 设置 <code>base</code> 路径</p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">base</span>: <span class=\"hljs-string\">\'/blog/\'</span>\n</code></pre>\n<blockquote>\n<p><code>config/index.js</code> 修改 <code>assetsPublicPath</code></p>\n</blockquote>\n<pre><code class=\"lang-js\"><span class=\"hljs-attribute\">assetsPublicPath</span>: <span class=\"hljs-string\">\'/blog/\'</span>\n</code></pre>\n<h2 id=\"nginx-\">nginx配置</h2>\n<pre><code class=\"lang-nginx\">location /blog {\n  try_files <span class=\"hljs-variable\">$uri</span> <span class=\"hljs-variable\">$uri</span>/ <span class=\"hljs-regexp\">/blog/index</span>.html;\n}\n</code></pre>',NULL,NULL),
	(39,39,1524096000000,'css,javascript','CSS 和 JS 实现持续的动画效果','<p>逛论坛的时候看到一个问题, <code>js</code>是怎么实现持续的动画效果的? 第一时间想到的是定时器, 后来看到有同学提到了 <code>requestAnimationFrame</code>, 由于之前没有对相关方法有所了解, 于是便去查了下, 顺便也记录了下 <code>animation</code> 的使用.</p>','<h1 id=\"css-js-\">CSS 和 JS 实现持续的动画效果</h1>\n<p>逛论坛的时候看到一个问题, <code>js</code>是怎么实现持续的动画效果的? 第一时间想到的是定时器, 后来看到有同学提到了 <code>requestAnimationFrame</code>, 由于之前没有对相关方法有所了解, 于是便去查了下, 顺便也记录了下 <code>animation</code> 的使用.</p>\n<h2 id=\"animation-css-\">animation(CSS)</h2>\n<h3 id=\"-\">兼容性与属性</h3>\n<blockquote>\n<p>猛戳<a href=\"https://caniuse.com/#search=animation\">这里</a>查看兼容性</p>\n</blockquote>\n<ul>\n<li>animation-name: 动画名称</li>\n<li>animation-duration: 动画时长</li>\n<li>animation-timing-function: 动画执行方式</li>\n<li>animation-delay: 动画延迟执行时间</li>\n<li>animation-iteration-count: 动画执行次数</li>\n<li>animation-direction: 是否反向执行动画</li>\n<li>animation-fill-mode: 动画执行前后的样式</li>\n</ul>\n<h3 id=\"-\">实例</h3>\n<p><a href=\"https://jsfiddle.net/tbqagefk/\">jsfiddle预览</a></p>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.box</span> <span class=\"hljs-rules\">{\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">200</span>px</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">200</span>px</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> aqua</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> absolute</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span></span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">animation</span>:<span class=\"hljs-value\"> test <span class=\"hljs-number\">3</span>s linear <span class=\"hljs-number\">2</span>s infinite</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n<span class=\"hljs-at_rule\">@<span class=\"hljs-keyword\">keyframes</span> test </span>{\n  <span class=\"hljs-tag\">from</span> <span class=\"hljs-rules\">{\n  <span class=\"hljs-rule\">}</span></span>\n  <span class=\"hljs-tag\">to</span> <span class=\"hljs-rules\">{\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">50</span>px</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">50</span>px</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background-color</span>:<span class=\"hljs-value\"> red</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">opacity</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0.5</span></span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">500</span>px</span></span>;\n    <span class=\"hljs-rule\"><span class=\"hljs-attribute\">top</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">500</span>px</span></span>;\n  <span class=\"hljs-rule\">}</span></span>\n}\n</code></pre>\n<pre><code class=\"lang-html\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-type\">class</span>=<span class=\"hljs-string\">\"box\"</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n</code></pre>\n<h2 id=\"requestanimationframe-js-\">requestAnimationFrame(JS)</h2>\n<h3 id=\"-\">兼容性与基本概念</h3>\n<blockquote>\n<p>猛戳<a href=\"https://caniuse.com/#search=requestAnimationFrame\">这里</a>查看兼容性</p>\n</blockquote>\n<p>优势：</p>\n<ul>\n<li>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果</li>\n<li>一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力</li>\n</ul>\n<p>使用：</p>\n<blockquote>\n<p>持续调用 <code>requestAnimFrame</code> 即可</p>\n</blockquote>\n<blockquote>\n<p>可以使用 <code>cancelAnimationFrame</code> 清除动画</p>\n</blockquote>\n<h3 id=\"-\">举例</h3>\n<p><a href=\"https://jsfiddle.net/aotc24bx/90/\">jsfiddle预览</a></p>\n<pre><code class=\"lang-css\"><span class=\"hljs-id\">#anim</span> <span class=\"hljs-rules\">{\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">position</span>:<span class=\"hljs-value\"> absolute</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">left</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">0</span>px</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">width</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">150</span>px</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">150</span>px</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">line-height</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">150</span>px</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">background</span>:<span class=\"hljs-value\"> aqua</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">color</span>:<span class=\"hljs-value\"> white</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">border-radius</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">10</span>px</span></span>;\n  <span class=\"hljs-rule\"><span class=\"hljs-attribute\">padding</span>:<span class=\"hljs-value\"> <span class=\"hljs-number\">1</span>em</span></span>;\n<span class=\"hljs-rule\">}</span></span>\n</code></pre>\n<pre><code class=\"lang-html\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-property\">id</span>=<span class=\"hljs-string\">\"anim\"</span>&gt; Click here <span class=\"hljs-keyword\">to</span> start animation&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n</code></pre>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">// 兼容性处理</span>\nwindow.requestAnimFrame = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n  <span class=\"hljs-keyword\">return</span> (\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(callback, element)</span> {</span>\n      window.setTimeout(callback, <span class=\"hljs-number\">1000</span> / <span class=\"hljs-number\">60</span>)\n    }\n  )\n})()\n\n<span class=\"hljs-keyword\">var</span> elem = document.getElementById(<span class=\"hljs-string\">\'anim\'</span>)\n<span class=\"hljs-keyword\">var</span> startTime = <span class=\"hljs-literal\">undefined</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span><span class=\"hljs-params\">(time)</span> {</span>\n  time = <span class=\"hljs-built_in\">Date</span>.now()\n  <span class=\"hljs-keyword\">if</span> (startTime === <span class=\"hljs-literal\">undefined</span>) {\n    startTime = time\n  }\n  elem.style.left = ((time - startTime) / <span class=\"hljs-number\">10</span>) % <span class=\"hljs-number\">300</span> + <span class=\"hljs-string\">\'px\'</span>\n  elem.style.top = ((time - startTime) / <span class=\"hljs-number\">10</span>) % <span class=\"hljs-number\">300</span> + <span class=\"hljs-string\">\'px\'</span>\n  elem.style.borderRadius = ((time - startTime) / <span class=\"hljs-number\">10</span>) % <span class=\"hljs-number\">300</span> + <span class=\"hljs-string\">\'px\'</span>\n  elem.style.opacity = <span class=\"hljs-built_in\">Math</span>.floor((time - startTime / <span class=\"hljs-number\">100</span>)) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0.3</span>\n}\n\nelem.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n  (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">animloop</span><span class=\"hljs-params\">()</span> {</span>\n    render()\n    requestAnimFrame(animloop, elem)\n  })()\n}\n</code></pre>\n<h2 id=\"-\">参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\">requestAnimationFrame MDN</a></p>\n<p><a href=\"http://javascript.ruanyifeng.com/htmlapi/requestanimationframe.html\">requestanimationframe</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation\">animation MDN</a></p>',NULL,NULL),
	(40,40,1525737600000,'vue,nginx','vue首屏加载优化','<p>项目基于 <code>vue-cli</code> 搭建, 部署采用 <code>nginx</code> 服务.</p>','<h1 id=\"vue-\">vue首屏加载优化</h1>\n<p>项目基于 <code>vue-cli</code> 搭建, 部署采用 <code>nginx</code> 服务.</p>\n<h2 id=\"-cdn\">使用CDN</h2>\n<p>首先将 <code>vue</code>, <code>vue-router</code> 从 <code>vendor.js</code> 中分离出来(若使用 <code>vuex</code>, 则将 <code>vuex</code> 也分离)</p>\n<p>1.在 <code>index.html</code> 中引入</p>\n<pre><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"//cdn.bootcss.com/vue/2.5.2/vue.min.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"//cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js\"</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</code></pre>\n<p>2.修改 <code>build/webpack.base.conf.js</code>, 配置 <code>externals</code></p>\n<pre><code class=\"lang-js\">externals: {\n    <span class=\"hljs-string\">\'vue\'</span>: <span class=\"hljs-string\">\'Vue\'</span>,\n    <span class=\"hljs-string\">\'vue-router\'</span>: <span class=\"hljs-string\">\'VueRouter\'</span>\n  }\n</code></pre>\n<p>3.修改 <code>src/router/index.js</code>, 注释以下两行</p>\n<pre><code class=\"lang-js\">// <span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> Router <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue-router\'</span>\n<span class=\"hljs-keyword\">import</span> index <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/components/index\'</span>\n\n// Vue.use(Router)\n</code></pre>\n<h2 id=\"-\">组件懒加载</h2>\n<p>将加载全部组件改成按需加载加载</p>\n<p>修改 <code>src/router/index.js</code>, 将组件由 <code>import</code> 引入换成 <code>require.ensure</code> 引入</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-reserved\">import</span> index from <span class=\"hljs-string\">\'@/components/index\'</span>\n<span class=\"hljs-regexp\">//</span> 修改组件引入方式\n<span class=\"hljs-reserved\">const</span> index = r<span class=\"hljs-function\"> =&gt;</span> <span class=\"hljs-built_in\">require</span>.ensure<span class=\"hljs-function\"><span class=\"hljs-params\">([], () =&gt; r(<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'@/components/index\'</span>)))</span></span>\n</code></pre>\n<h2 id=\"nginx-gzip\">nginx 开启 gzip</h2>\n<pre><code class=\"lang-conf\">gzip <span class=\"hljs-function_start\"><span class=\"hljs-keyword\">on</span></span>;\ngzip_min_length <span class=\"hljs-number\">1</span>k;\ngzip_buffers <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">16</span>k;\ngzip_comp_level <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-comment\"># 要压缩的类型</span>\ngzip_types <span class=\"hljs-type\">text</span>/plain <span class=\"hljs-type\">application</span>/javascript <span class=\"hljs-type\">application</span>/x-javascript <span class=\"hljs-type\">text</span>/css <span class=\"hljs-type\">application</span>/xml <span class=\"hljs-type\">text</span>/javascript image/jpeg image/gif image/png;\n</code></pre>\n<p>更多关于 <code>nginx gzip</code>, 可前往<a href=\"http://nginx.org/en/docs/http/ngx_http_gzip_module.html\">官方文档</a>了解</p>',NULL,NULL),
	(41,41,1526169600000,'javascript','理解js中的事件循环','<p>本文主要介绍 <code>JavaScript</code> 中的<code>Event Loop（事件循环）</code> 机制。</p>','<h1 id=\"javascript-\">javascript 事件循环</h1>\n<p>可以先来看这样的一段代码, 可以思考下会输出什么结果:</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'event start\'</span>)\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'setTimeout\'</span>);\n});\n\nnew Promise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(resolve,reject)</span>{</span>\n    <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'promise start\'</span>)\n    resolve()\n}).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'promise end\'</span>)\n})\n<span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'event end\'</span>)\n</code></pre>\n<p>正确的输出结果如下:</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-comment\">// event start</span>\n<span class=\"hljs-comment\">// promise start</span>\n<span class=\"hljs-comment\">// event end</span>\n<span class=\"hljs-comment\">// promise end</span>\n<span class=\"hljs-comment\">// setTimeout</span>\n</code></pre>\n<p>那么, 为什么会得到这样的结果呢? 这就和 <code>javascript</code> 的执行机制密切相关了.</p>\n<h2 id=\"-\">事件队列和事件循环</h2>\n<p><code>javascript</code> 是一门单线程的语言, 这就意味着在执行代码的时候, 都只有一个主线程来处理所有的任务.</p>\n<p>我们都知道 <code>javascript</code> 包括同步代码和异步代码, 那么 <code>javascript</code> 是怎么处理这两种情况的呢?</p>\n<p>可以通过下图简单说明:</p>\n<p><img src=\"http://47.98.208.58/images/event-loop2.jpg\" alt=\"event loop\"></p>\n<ul>\n<li>同步和异步任务分别进入不同的执行 <code>场所</code>, 同步的进入主线程，异步的进入 <code>Event Table</code> 并注册函数</li>\n<li>当指定的事情完成时, <code>Event Table</code> 会将这个函数(回调函数)移入 <code>Event Queue</code></li>\n<li>主线程内的任务执行完毕为空, 会去 <code>Event Queue</code> 读取对应的函数，进入主线程执行</li>\n<li>上述过程会不断重复, 也就是常说的 <code>Event Loop(事件循环)</code></li>\n</ul>\n<p>这里我们引进了 <code>Event Queue</code> 事件队列这一概念. 所有异步操作的回调都会进入到这里. 然后等到主线程空闲, 就会从这里调取回调执行.</p>\n<p><img src=\"http://47.98.208.58/images/event-loop.jpg\" alt=\"event loop\"></p>\n<p>可以通过上图中了解 <code>event loop</code>, 事件队列以及主线程之间的关系.</p>\n<h2 id=\"settimeout\">setTimeout</h2>\n<p><code>setTimeout</code> 相信大家都有使用过, 可以延时执行并且是异步执行的.</p>\n<p>但是有时候我们得到的结果往往是代码实际执行的时间比我们想要延时执行的时间要久。这又是为什么呢?</p>\n<p>这就和我们之前所说的 <code>Event Loop</code> 有关了, 我们可以来具体看下 <code>setTimeout</code> 的执行步骤:</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-function\">setTimeout(function ()</span> {\n    <span class=\"hljs-function\">asyncFn()</span>\n}, 1000);\n\n<span class=\"hljs-function\">syncFn()</span>\n</code></pre>\n<ul>\n<li><code>asyncFn</code> 将异步执行函数放在 <code>Event Table</code>, 并且开始计时</li>\n<li>开始执行 <code>syncFn</code>, 但是 <code>syncFn</code> 可能需要处理的内容很多, 执行时间超过 <code>1</code> 秒, 但是计时还在继续</li>\n<li>计时到达 <code>1</code> 秒, <code>setTimeout</code> 延时完成, <code>asyncFn</code> 进入 <code>Event Queue</code> 事件队列, 但是主线程还在执行, 所以只能等待</li>\n<li><code>syncFn</code> 执行完成, 此时 <code>asyncFn</code> 从事件队列中进入主线程执行</li>\n</ul>\n<p>所以有时候会出现代码实际执行时间比延时时间长的情况.</p>\n<h2 id=\"macro-task-micro-task\">macro-task 和 micro-task</h2>\n<p>以上我们只是简单的分为了同步任务和异步任务. 其实我们还有更加具体的定义:</p>\n<ul>\n<li><code>macro-task</code> 宏任务: <code>setTimeout</code>, <code>setInterval</code></li>\n<li><code>micro-task</code> 微任务: <code>Promise</code></li>\n</ul>\n<p>之前我们说过异步任务会进入到事件队列中, 不同类型的任务会进入到不同的队列中, 比如宏任务会进入到宏任务队列中, 微任务会进入到微任务队列中.</p>\n<p>我们可以参考下图来理解事件循环, 宏任务, 微任务的关系:</p>\n<p><img src=\"http://47.98.208.58/images/event-loop3.jpg\" alt=\"event loop\"></p>\n<p>我们只要记住 <strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong></p>\n<p>这时候我们就可以解释一开始的代码执行结果了:</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'event start\'</span>)\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'setTimeout\'</span>);\n});\n\nnew Promise(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(resolve,reject)</span>{</span>\n    <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'promise start\'</span>)\n    resolve()\n}).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n    <span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'promise end\'</span>)\n})\n<span class=\"hljs-transposed_variable\">console.</span><span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\'event end\'</span>)\n</code></pre>\n<ul>\n<li>主线程执行按顺序代码</li>\n<li>遇到 <code>setTimeout</code>, 回调进入到宏任务队列上</li>\n<li>遇到 <code>Promise</code>, 立即执行, <code>then</code> 函数进入到微任务队列</li>\n<li>同步代码执行结束, 主线程检查是否存在微任务, 发现 <code>then</code>, 执行</li>\n<li>微任务执行完毕, 再去查找宏任务 <code>setTimeout</code>, 执行</li>\n<li><code>setTimeout</code> 执行结束, 检查是否存在微任务, 不存在, 结束.</li>\n</ul>\n<h2 id=\"-\">参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26229293\">https://zhuanlan.zhihu.com/p/26229293</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33058983\">https://zhuanlan.zhihu.com/p/33058983</a></li>\n<li><a href=\"https://juejin.im/post/59e85eebf265da430d571f89\">https://juejin.im/post/59e85eebf265da430d571f89</a></li>\n<li><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></li>\n</ul>\n',NULL,NULL);

/*!40000 ALTER TABLE `articles` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table relations
# ------------------------------------------------------------

DROP TABLE IF EXISTS `relations`;

CREATE TABLE `relations` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `postId` int(11) unsigned DEFAULT NULL,
  `tagId` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `1` (`postId`),
  KEY `2` (`tagId`),
  CONSTRAINT `1` FOREIGN KEY (`postId`) REFERENCES `articles` (`id`),
  CONSTRAINT `2` FOREIGN KEY (`tagId`) REFERENCES `tags` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `relations` WRITE;
/*!40000 ALTER TABLE `relations` DISABLE KEYS */;

INSERT INTO `relations` (`id`, `postId`, `tagId`)
VALUES
	(1,5,1),
	(2,6,1),
	(3,14,1),
	(4,36,1),
	(5,39,1),
	(6,3,2),
	(7,11,2),
	(8,12,2),
	(9,13,2),
	(10,15,2),
	(11,19,2),
	(12,21,2),
	(13,22,2),
	(14,23,2),
	(15,24,2),
	(16,32,2),
	(17,33,2),
	(18,34,2),
	(19,35,2),
	(20,39,2),
	(21,38,3),
	(22,27,4),
	(23,30,4),
	(24,1,5),
	(25,2,6),
	(26,4,6),
	(27,8,6),
	(28,9,6),
	(29,20,6),
	(30,26,6),
	(31,29,6),
	(32,31,6),
	(33,38,6),
	(34,2,7),
	(35,7,8),
	(36,10,8),
	(37,17,8),
	(38,18,8),
	(39,7,9),
	(40,10,9),
	(41,17,9),
	(42,18,9),
	(43,9,10),
	(44,31,10),
	(45,8,11),
	(46,11,12),
	(47,12,12),
	(48,13,12),
	(49,14,13),
	(50,15,14),
	(51,16,15),
	(52,28,15),
	(53,16,16),
	(54,30,17),
	(55,28,18),
	(56,19,19),
	(57,21,19),
	(58,29,20),
	(59,33,21),
	(60,32,22),
	(61,35,22),
	(62,37,23),
	(63,37,24),
	(64,19,22),
	(65,21,22),
	(66,40,3),
	(67,40,6),
	(68,41,2);

/*!40000 ALTER TABLE `relations` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tags
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tags`;

CREATE TABLE `tags` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `tag` varchar(100) DEFAULT NULL,
  `tagId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `tags` WRITE;
/*!40000 ALTER TABLE `tags` DISABLE KEYS */;

INSERT INTO `tags` (`id`, `tag`, `tagId`)
VALUES
	(1,'css',1),
	(2,'javascript',2),
	(3,'nginx',3),
	(4,'web',4),
	(5,'nodejs',5),
	(6,'vue',6),
	(7,'vuex',7),
	(8,'bug',8),
	(9,'FAQ',9),
	(10,'vue-router',10),
	(11,'vue-cli',11),
	(12,'notes',12),
	(13,'less',13),
	(14,'wechat',14),
	(15,'tomcat',15),
	(16,'java',16),
	(17,'http',17),
	(18,'mac',18),
	(19,'promise',19),
	(20,'axios',20),
	(21,'module',21),
	(22,'es6',22),
	(23,'linux',23),
	(24,'vim',24);

/*!40000 ALTER TABLE `tags` ENABLE KEYS */;
UNLOCK TABLES;



/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
